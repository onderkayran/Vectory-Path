<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Vectory Path</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" />
  <style>
    body {
      background-color: #f5f6fa;
      padding: 20px;
    }
    .game-container {
      max-width: 500px;
      margin: 0 auto;
      background-color: #ffffff;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }
    canvas {
      border: 2px solid #e0e0e0;
      background-color: white;
      display: block;
      margin: 0 auto 20px auto;
      width: 100%;
      max-width: 450px;
      height: 450px;
    }
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0,0,0,0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background-color: white;
      padding: 25px;
      border-radius: 10px;
      max-width: 500px;
      width: 90%;
      position: relative;
    }
    .close-modal {
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 24px;
      cursor: pointer;
      color: #777;
    }
    .winner-modal {
      background-color: #EA4335;
      color: white;
      text-align: center;
    }
    .loser-modal {
      background-color: #34A853;
      color: white;
      text-align: center;
    }
    .obstacle-point {
      position: absolute;
      font-weight: bold;
      color: #000;
    }
    .tutorial-canvas-container {
      border: 2px solid #eee;
      border-radius: 8px;
      margin: 0 auto;
      width: fit-content;
    }
    .tutorial-step {
      transition: all 0.3s ease;
    }
    .tutorial-nav-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 20px;
    }
    .highlight-point {
      animation: pulse 1s infinite;
      box-shadow: 0 0 15px #FBBC05;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    #onlineStatus {
      display: none;
      margin-top: 10px;
    }
    #matchStatus {
      display: none;
      margin-top: 10px;
    }
    .player-badge {
      font-size: 0.8rem;
      padding: 3px 6px;
      border-radius: 4px;
    }
    .player1-badge {
      background-color: #EA4335;
      color: white;
    }
    .player2-badge {
      background-color: #5e35b1;
      color: white;
    }
    #matchProgress {
      margin-top: 10px;
      height: 5px;
    }
  </style>
</head>
<body>

<div class="game-container">
  <h2 class="text-center text-primary fw-bold">Vectory Path</h2>

  <div class="d-flex align-items-center mb-3">
    <label class="me-2">Grid:</label>
    <input type="number" id="gridWidth" class="form-control me-2" value="6" min="3" max="10" style="width: 60px;">
    <span class="me-2">x</span>
    <input type="number" id="gridHeight" class="form-control me-2" value="5" min="3" max="10" style="width: 60px;">
    
    <select id="difficultySelect" class="form-select me-2" style="width: 120px;">
      <option value="easy">Easy</option>
      <option value="medium">Medium</option>
      <option value="hard">Hard</option>
      <option value="expert" selected>Expert</option>
    </select>
    <select id="modeSelect" class="form-select me-2" style="width: 150px;">
      <option value="robot" selected>Robot ile Oyna</option>
      <option value="online">Online Oyna</option>
    </select>
    <button id="startButton" class="btn btn-primary me-2">Start</button>
    <button id="helpButton" class="btn btn-info text-white">Help</button>
  </div>

  <canvas id="gameCanvas"></canvas>

  <div id="onlineStatus" class="alert alert-warning">
    <strong>Online Oyun:</strong>
    <span id="gameStatusText">BaÄŸlanÄ±yor...</span>
    <span id="playerRoleBadge" class="badge ms-2"></span>
  </div>

  <div id="firstMoveHelp" class="alert alert-info mt-3" style="font-size: 14px;">
    <strong>Ä°lk Hamle YardÄ±mÄ±:</strong><br>
    Oyuna baÅŸlamak iÃ§in <span style="color:#34A853;font-weight:bold;">sol alt kÃ¶ÅŸeye (yeÅŸil nokta)</span> komÅŸu olan noktalardan birine tÄ±klayÄ±n.
  </div>

  <div id="onlinePanel" class="mt-4 p-3 border rounded bg-light" style="display: none;">
    <h5 class="text-center mb-3 fw-bold">Online Oyun</h5>
    <button id="findMatchBtn" class="btn btn-primary w-100 mb-2">EÅŸleÅŸme Bul</button>
    <div id="matchStatus" class="alert alert-info mt-3">
      <span id="matchStatusText">EÅŸleÅŸme aranÄ±yor...</span>
      <div id="matchProgress" class="progress">
        <div class="progress-bar progress-bar-striped progress-bar-animated" style="width: 100%"></div>
      </div>
    </div>
  </div>
</div>

<!-- Help Modal -->
<div class="modal-overlay" id="helpModal">
  <div class="modal-content">
    <span class="close-modal" id="closeModal">Ã—</span>
    <h4 class="text-primary">NasÄ±l OynanÄ±r?</h4>
    <p>Oyunun amacÄ± baÅŸlangÄ±Ã§ noktasÄ±ndan bitiÅŸ noktasÄ±na ulaÅŸmaktÄ±r.</p>
    <ul>
      <li>Noktalar arasÄ±nda Ã§izgi Ã§izerek ilerlenir.</li>
      <li>YalnÄ±zca komÅŸu noktalara hamle yapÄ±labilir (Ã§apraz dahil).</li>
      <li>X ile iÅŸaretli noktalar engeldir, kullanÄ±lamaz.</li>
      <li>ðŸ”’ ile iÅŸaretli noktalar kilitlidir, kullanÄ±lamaz (5x5 ve Ã¼zeri gridlerde).</li>
      <li>Rakibini hamlesiz bÄ±rakan taraf kazanÄ±r.</li>
    </ul>
    <h5 class="mt-3">Online Mod:</h5>
    <p>Rastgele eÅŸleÅŸme ile gerÃ§ek oyuncularla oynayabilirsiniz.</p>
  </div>
</div>

<!-- Tutorial Modal -->
<div class="modal-overlay" id="tutorialModal" style="display:flex;">
  <div class="modal-content" style="max-width:600px;">
    <span class="close-modal" id="closeTutorial">Ã—</span>
    <h4 class="text-primary mb-4">Vectory Path Ã–ÄŸretici</h4>
    
    <div class="tutorial-step active" data-step="1">
      <h5>1. BaÅŸlangÄ±Ã§ ve BitiÅŸ NoktalarÄ±</h5>
      <div class="tutorial-canvas-container mb-3">
        <canvas id="tutorialCanvas1" width="400" height="300"></canvas>
      </div>
      <p>YeÅŸil nokta (sol alt) baÅŸlangÄ±Ã§, kÄ±rmÄ±zÄ± nokta (saÄŸ Ã¼st) bitiÅŸ noktasÄ±dÄ±r.</p>
    </div>
    
    <div class="tutorial-step" data-step="2" style="display:none;">
      <h5>2. Ä°lk Hamleniz</h5>
      <div class="tutorial-canvas-container mb-3">
        <canvas id="tutorialCanvas2" width="400" height="300"></canvas>
      </div>
      <p>BaÅŸlangÄ±Ã§ noktasÄ±nÄ±n komÅŸularÄ±na tÄ±klayarak ilk hamlenizi yapÄ±n.</p>
    </div>
    
    <div class="tutorial-step" data-step="3" style="display:none;">
      <h5>3. Yol OluÅŸturma</h5>
      <div class="tutorial-canvas-container mb-3">
        <canvas id="tutorialCanvas3" width="400" height="300"></canvas>
      </div>
      <p>KomÅŸu noktalar arasÄ±nda Ã§izgiler Ã§izerek bitiÅŸe ulaÅŸmaya Ã§alÄ±ÅŸÄ±n.</p>
    </div>
    
    <div class="d-flex justify-content-between mt-4">
      <button id="prevStep" class="btn btn-secondary" disabled>Ã–nceki</button>
      <button id="nextStep" class="btn btn-primary">Sonraki</button>
    </div>
    <button id="skipTutorial" class="btn btn-outline-secondary mt-2 w-100">Ã–ÄŸreticiyi Atla</button>
  </div>
</div>

<!-- Winner Modal -->
<div class="modal-overlay" id="winnerModal" style="display:none;">
  <div class="modal-content winner-modal">
    <h2 id="winnerText">Tebrikler KazandÄ±nÄ±z!</h2>
    <button id="playAgainBtn" class="btn btn-light mt-3">Tekrar Oyna</button>
  </div>
</div>

<!-- Loser Modal -->
<div class="modal-overlay" id="loserModal" style="display:none;">
  <div class="modal-content loser-modal">
    <h2 id="loserText">Maalesef Kaybettiniz!</h2>
    <button id="tryAgainBtn" class="btn btn-light mt-3">Yeni Oyun</button>
  </div>
</div>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

<script>
  // Firebase konfigÃ¼rasyonu
  const firebaseConfig = {
    apiKey: "AIzaSyB4lQ2KZanAK3fzRmwXhedh4rtfb6PZ9FY",
    authDomain: "vectory-path.firebaseapp.com",
    databaseURL: "https://vectory-path-default-rtdb.firebaseio.com",
    projectId: "vectory-path",
    storageBucket: "vectory-path.firebasestorage.app",
    messagingSenderId: "462766360594",
    appId: "1:462766360594:web:9a9443f056d45155c8b0cb",
    measurementId: "G-KCKK8ZRHTT"
  };

  // Firebase baÅŸlatma
  firebase.initializeApp(firebaseConfig);
  const database = firebase.database();

  // Oyun durumu
  let gridW = 6, gridH = 5;
  let edges = [];
  let currentPlayer = 1;
  let lastPoint = null;
  let gameActive = true;
  let obstacles = [];
  let currentGameRef = null;
  let isOnlineGame = false;
  let playerRole = null;
  let myPlayerId = Math.random().toString(36).substr(2, 9); // Rastgele oyuncu ID
  let matchmakingRef = null;
  let matchTimeout = null;

  // Canvas ve UI elementleri
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const startButton = document.getElementById('startButton');
  const helpButton = document.getElementById('helpButton');
  const helpModal = document.getElementById('helpModal');
  const closeModal = document.getElementById('closeModal');
  const winnerModal = document.getElementById('winnerModal');
  const winnerText = document.getElementById('winnerText');
  const playAgainBtn = document.getElementById('playAgainBtn');
  const loserModal = document.getElementById('loserModal');
  const loserText = document.getElementById('loserText');
  const tryAgainBtn = document.getElementById('tryAgainBtn');
  const difficultySelect = document.getElementById('difficultySelect');
  const modeSelect = document.getElementById('modeSelect');
  const findMatchBtn = document.getElementById('findMatchBtn');
  const matchStatus = document.getElementById('matchStatus');
  const matchStatusText = document.getElementById('matchStatusText');
  const matchProgress = document.getElementById('matchProgress');

  // Canvas boyutlandÄ±rma
  function resizeCanvas() {
    const container = document.querySelector('.game-container');
    const size = Math.min(container.clientWidth * 0.9, 500);
    canvas.width = size;
    canvas.height = size;
    drawGrid();
  }

  // Grid koordinatlarÄ±nÄ± canvas koordinatlarÄ±na Ã§evir
  function toCanvasCoords(p) {
    const padding = canvas.width * 0.1;
    const usableW = canvas.width - 2 * padding;
    const usableH = canvas.height - 2 * padding;
    return {
      x: Math.round(padding + (p.x * usableW) / (gridW - 1)),
      y: Math.round(padding + (p.y * usableH) / (gridH - 1))
    };
  }

  // Engel oluÅŸtur
  function generateObstacles() {
    obstacles = [];
    const difficulty = difficultySelect.value;
    let obstacleCount;
    
    switch(difficulty) {
      case 'easy': obstacleCount = Math.floor(gridW * gridH * 0.05); break;
      case 'medium': obstacleCount = Math.floor(gridW * gridH * 0.1); break;
      case 'hard': obstacleCount = Math.floor(gridW * gridH * 0.15); break;
      case 'expert': obstacleCount = 0; break;
    }
    
    // Kilitli noktalarÄ± ekle (5x5 ve Ã¼zeri gridlerde)
    if (gridW >= 5 && gridH >= 5) {
      addLockedPoints(4);
    }
    
    const protectedPoints = [
      {x: 0, y: gridH - 1}, {x: gridW - 1, y: 0},
      {x: 0, y: gridH - 2}, {x: 1, y: gridH - 1},
      {x: 1, y: gridH - 2}, {x: gridW - 1, y: 1},
      {x: gridW - 2, y: 0}, {x: gridW - 2, y: 1}
    ];
    
    let attempts = 0;
    while (obstacles.length < obstacleCount && attempts < 100) {
      attempts++;
      const x = Math.floor(Math.random() * gridW);
      const y = Math.floor(Math.random() * gridH);
      
      const isProtected = protectedPoints.some(p => p.x === x && p.y === y);
      const exists = obstacles.some(obs => obs.x === x && obs.y === y);
      
      if (!isProtected && !exists) {
        // Engel eklemeden Ã¶nce yolun mÃ¼mkÃ¼n olduÄŸunu kontrol et
        const tempObstacles = [...obstacles, {x, y}];
        const start = {x: 0, y: gridH - 1};
        const end = {x: gridW - 1, y: 0};
        if (isPathPossible(start, end, tempObstacles)) {
          obstacles.push({x, y});
        }
      }
    }
    
    // Online oyunda engelleri paylaÅŸ
    if (isOnlineGame && playerRole === 'player1' && currentGameRef) {
      currentGameRef.update({ 
        obstacles: obstacles,
        status: 'playing'
      });
    }
  }

  // Kilitli noktalar ekle
  function addLockedPoints(count) {
    const lockedPoints = [];
    const protectedPoints = [
      {x: 0, y: gridH - 1}, {x: gridW - 1, y: 0},
      {x: 0, y: gridH - 2}, {x: 1, y: gridH - 1},
      {x: 1, y: gridH - 2}, {x: gridW - 1, y: 1},
      {x: gridW - 2, y: 0}, {x: gridW - 2, y: 1}
    ];
    
    while (lockedPoints.length < count) {
      const x = Math.floor(Math.random() * gridW);
      const y = Math.floor(Math.random() * gridH);
      
      const isProtected = protectedPoints.some(p => p.x === x && p.y === y);
      const exists = lockedPoints.some(p => p.x === x && p.y === y);
      
      if (!isProtected && !exists) {
        lockedPoints.push({x, y, locked: true});
      }
    }
    
    obstacles.push(...lockedPoints);
  }

  function isPathPossible(start, end, obstacles) {
    const visited = new Set();
    const queue = [start];
    const key = p => `${p.x},${p.y}`;
    
    while (queue.length > 0) {
      const current = queue.shift();
      if (current.x === end.x && current.y === end.y) return true;
      
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = current.x + dx;
          const ny = current.y + dy;
          if (nx >= 0 && ny >= 0 && nx < gridW && ny < gridH) {
            const next = {x: nx, y: ny};
            if (!obstacles.some(o => o.x === nx && o.y === ny) && !visited.has(key(next))) {
              visited.add(key(next));
              queue.push(next);
            }
          }
        }
      }
    }
    return false;
  }

  // Grid Ã§iz
  function drawGrid() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const padding = canvas.width * 0.1;
    const usableW = canvas.width - 2 * padding;
    const usableH = canvas.height - 2 * padding;

    // Ã‡izgileri Ã§iz
    ctx.lineWidth = 4;
    for (let edge of edges) {
      const from = toCanvasCoords(edge.from);
      const to = toCanvasCoords(edge.to);
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);
      ctx.strokeStyle = edge.player === 1 ? "#EA4335" : "#5e35b1";
      ctx.stroke();
    }

    // NoktalarÄ± Ã§iz
    for (let y = 0; y < gridH; y++) {
      for (let x = 0; x < gridW; x++) {
        const point = {x, y};
        const isObstacle = obstacles.some(obs => obs.x === x && obs.y === y && !obs.locked);
        const isLocked = obstacles.some(obs => obs.x === x && obs.y === y && obs.locked);
        const {x: px, y: py} = toCanvasCoords(point);
        
        if (isLocked) {
          // Kilitli noktalarÄ± Ã¶zel iÅŸaretle
          ctx.beginPath();
          ctx.arc(px, py, 8, 0, Math.PI * 2);
          ctx.fillStyle = "#FF5733";
          ctx.fill();
          ctx.font = 'bold 12px Arial';
          ctx.fillStyle = "#000";
          ctx.fillText('ðŸ”’', px - 6, py + 5);
          continue;
        }
        
        if (isObstacle) {
          ctx.font = 'bold 16px Arial';
          ctx.fillStyle = '#000';
          ctx.fillText('X', px - 5, py + 5);
          continue;
        }
        
        ctx.beginPath();
        ctx.arc(px, py, 8, 0, Math.PI * 2);
        
        if (x === 0 && y === gridH - 1) {
          ctx.fillStyle = "#34A853";
        } else if (x === gridW - 1 && y === 0) {
          ctx.fillStyle = "#EA4335";
        } else if (lastPoint && x === lastPoint.x && y === lastPoint.y) {
          ctx.fillStyle = "#FBBC05";
        } else {
          ctx.fillStyle = "#4285F4";
        }
        ctx.fill();
      }
    }
  }

  // Ä°ki nokta komÅŸu mu kontrolÃ¼
  function isAdjacent(p1, p2) {
    const dx = Math.abs(p1.x - p2.x);
    const dy = Math.abs(p1.y - p2.y);
    return (dx <= 1 && dy <= 1) && !(dx === 0 && dy === 0);
  }

  // Ã‡izgi var mÄ± kontrolÃ¼
  function edgeExists(p1, p2) {
    return edges.some(e =>
      (e.from.x === p1.x && e.from.y === p1.y && e.to.x === p2.x && e.to.y === p2.y) ||
      (e.to.x === p1.x && e.to.y === p1.y && e.from.x === p2.x && e.from.y === p2.y)
    );
  }

  // Engel kontrolÃ¼
  function isObstacle(p) {
    return obstacles.some(obs => obs.x === p.x && obs.y === p.y);
  }

  // Kilitli nokta kontrolÃ¼
  function isLocked(p) {
    return obstacles.some(obs => obs.x === p.x && obs.y === p.y && obs.locked);
  }

  // BitiÅŸ noktasÄ± kontrolÃ¼
  function isEndPoint(p) {
    return p.x === gridW - 1 && p.y === 0;
  }

  // Hamle yapabilme durumunu kontrol et
  function canMove(from) {
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        const nx = from.x + dx;
        const ny = from.y + dy;
        if (nx >= 0 && ny >= 0 && nx < gridW && ny < gridH) {
          const next = { x: nx, y: ny };
          if (!edgeExists(from, next) && !isObstacle(next)) {
            return true;
          }
        }
      }
    }
    return false;
  }

  // Hamle yap
  function makeMove(point) {
    if (!gameActive || isLocked(point)) return;

    const move = {
      from: lastPoint || { x: 0, y: gridH - 1 },
      to: point,
      player: currentPlayer
    };

    if (isOnlineGame) {
      sendOnlineMove(move);
    } else if (modeSelect.value === 'robot' && currentPlayer === 2) {
      setTimeout(robotMove, 500);
    }
    
    processMoveLocally(move);
  }

  function processMoveLocally(move) {
    edges.push({
      from: move.from,
      to: move.to,
      player: move.player
    });
    
    lastPoint = move.to;
    currentPlayer = move.player === 1 ? 2 : 1;
    drawGrid();
    
    if (isEndPoint(move.to)) {
      endGame(move.player);
    } else if (!canMove(lastPoint)) {
  endGame(move.player);
}
  }

  function endGame(winner) {
    gameActive = false;
    
    if (isOnlineGame) {
      endOnlineGame(winner);
    } else {
      if (winner === 1) {
        winnerText.textContent = "Maalesef Kaybettiniz!";
        winnerModal.style.display = 'flex';
      } else {
        loserText.textContent = modeSelect.value === 'robot' 
          ? "Tebrikler KazandÄ±nÄ±z!" 
          : "Maalesef Kaybettiniz!";
        loserModal.style.display = 'flex';
      }
    }
  }

  // Robot hamlesi
  function robotMove() {
    if (!gameActive || modeSelect.value !== "robot") return;
    
    const endPoint = { x: gridW - 1, y: 0 };
    const difficulty = difficultySelect.value;
    
    // 1. Ã–ncelik: Oyuncuyu hamlesiz bÄ±rakarak kazanma
    const blockingMoves = findBlockingMoves();
    if (blockingMoves.length > 0 && (difficulty === 'hard' || difficulty === 'expert')) {
      makeMove(blockingMoves[0]);
      return;
    }
    
    // 2. Ã–ncelik: BitiÅŸ noktasÄ±na ulaÅŸma fÄ±rsatÄ± varsa ulaÅŸ
    if (isAdjacent(lastPoint, endPoint) && !edgeExists(lastPoint, endPoint)) {
      makeMove(endPoint);
      return;
    }
    
    // 3. Zorluk seviyesine gÃ¶re strateji
    if (difficulty === 'easy') {
      // Rastgele hamle
      const moves = [];
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = lastPoint.x + dx;
          const ny = lastPoint.y + dy;
          if (nx >= 0 && ny >= 0 && nx < gridW && ny < gridH) {
            const next = { x: nx, y: ny };
            if (!edgeExists(lastPoint, next) && !isObstacle(next)) {
              moves.push(next);
            }
          }
        }
      }
      if (moves.length > 0) {
        const randomMove = moves[Math.floor(Math.random() * moves.length)];
        makeMove(randomMove);
        return;
      }
    } else if (difficulty === 'medium') {
      // %50 rastgele, %50 stratejik hamle
      if (Math.random() > 0.5) {
        const moves = [];
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = lastPoint.x + dx;
            const ny = lastPoint.y + dy;
            if (nx >= 0 && ny >= 0 && nx < gridW && ny < gridH) {
              const next = { x: nx, y: ny };
              if (!edgeExists(lastPoint, next) && !isObstacle(next)) {
                moves.push(next);
              }
            }
          }
        }
        if (moves.length > 0) {
          const randomMove = moves[Math.floor(Math.random() * moves.length)];
          makeMove(randomMove);
          return;
        }
      }
    }
    
    // 4. Stratejik hamleler
    const moves = [];
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        const nx = lastPoint.x + dx;
        const ny = lastPoint.y + dy;
        if (nx >= 0 && ny >= 0 && nx < gridW && ny < gridH) {
          const next = { x: nx, y: ny };
          if (!edgeExists(lastPoint, next) && !isObstacle(next)) {
            let priority = 0;
            const distToEnd = Math.abs(nx - endPoint.x) + Math.abs(ny - endPoint.y);
            priority -= distToEnd * 2;
            
            if (difficulty === 'hard' || difficulty === 'expert') {
              const path = findPath(next, endPoint);
              if (path) priority -= path.length * 2;
            }
            
            moves.push({ point: next, priority });
          }
        }
      }
    }
    
    if (moves.length > 0) {
      moves.sort((a, b) => b.priority - a.priority);
      makeMove(moves[0].point);
    } else {
      endGame(1); // Oyuncu kazanÄ±r
    }
  }

  function findBlockingMoves() {
    const blockingMoves = [];
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        const nx = lastPoint.x + dx;
        const ny = lastPoint.y + dy;
        if (nx >= 0 && ny >= 0 && nx < gridW && ny < gridH) {
          const next = { x: nx, y: ny };
          if (!edgeExists(lastPoint, next) && !isObstacle(next)) {
            const tempEdges = [...edges, {from: lastPoint, to: next, player: 2}];
            if (!canMove(next)) {
              blockingMoves.push(next);
            }
          }
        }
      }
    }
    return blockingMoves;
  }

  function findPath(from, to) {
    const visited = new Set();
    const queue = [{ point: from, path: [] }];
    const key = p => `${p.x},${p.y}`;
    
    while (queue.length > 0) {
      const current = queue.shift();
      if (visited.has(key(current.point))) continue;
      visited.add(key(current.point));
      
      if (current.point.x === to.x && current.point.y === to.y) {
        return current.path;
      }
      
      // Ã–nce dÃ¼z (yatay/dikey) komÅŸularÄ± ekle
      const directions = [
        {dx: 1, dy: 0}, {dx: -1, dy: 0}, {dx: 0, dy: 1}, {dx: 0, dy: -1},
        {dx: 1, dy: 1}, {dx: 1, dy: -1}, {dx: -1, dy: 1}, {dx: -1, dy: -1}
      ];
      
      for (const dir of directions) {
        const nx = current.point.x + dir.dx;
        const ny = current.point.y + dir.dy;
        
        if (nx >= 0 && ny >= 0 && nx < gridW && ny < gridH && !isObstacle({x: nx, y: ny})) {
          const nextPoint = { x: nx, y: ny };
          const edgeExists = edges.some(e =>
            (e.from.x === current.point.x && e.from.y === current.point.y && 
             e.to.x === nextPoint.x && e.to.y === nextPoint.y) ||
            (e.to.x === current.point.x && e.to.y === current.point.y && 
             e.from.x === nextPoint.x && e.from.y === nextPoint.y)
          );
          
          if (!edgeExists) {
            const newPath = [...current.path, nextPoint];
            queue.push({ point: nextPoint, path: newPath });
          }
        }
      }
    }
    
    return null;
  }

  // TÄ±klama iÅŸleyici
  canvas.addEventListener("click", function(e) {
    if (!gameActive || (isOnlineGame && currentPlayer !== (playerRole === 'player1' ? 1 : 2))) return;

    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    
    let minDist = Infinity;
    let closestPoint = null;
    
    for (let y = 0; y < gridH; y++) {
      for (let x = 0; x < gridW; x++) {
        if (isObstacle({x, y})) continue;
        
        const canvasCoords = toCanvasCoords({x, y});
        const dist = Math.sqrt(Math.pow(mx - canvasCoords.x, 2) + Math.pow(my - canvasCoords.y, 2));
        
        if (dist < minDist && dist < 20) {
          minDist = dist;
          closestPoint = {x, y};
        }
      }
    }
    
    if (!closestPoint) return;
    const clicked = closestPoint;
    
    const startPoint = { x: 0, y: gridH - 1 };

    if (isEndPoint(clicked)) {
      if (lastPoint && isAdjacent(lastPoint, clicked) && !isObstacle(clicked)) {
        makeMove(clicked);
      }
      return;
    }

    if (!lastPoint) {
      if (isAdjacent(startPoint, clicked) && !edgeExists(startPoint, clicked) && !isObstacle(clicked)) {
        makeMove(clicked);
      }
      return;
    }

    if (isAdjacent(lastPoint, clicked) && !edgeExists(lastPoint, clicked) && !isObstacle(clicked)) {
      makeMove(clicked);
    }
  });

  // Online oyun fonksiyonlarÄ±
  function findOnlineMatch() {
    matchStatus.style.display = 'block';
    matchStatusText.textContent = "EÅŸleÅŸme aranÄ±yor...";
    findMatchBtn.disabled = true;
    
    // EÅŸleÅŸme kuyruÄŸuna ekle
    matchmakingRef = database.ref('matchmaking').push({
      playerId: myPlayerId,
      timestamp: firebase.database.ServerValue.TIMESTAMP,
      config: {
        gridWidth: parseInt(document.getElementById('gridWidth').value),
        gridHeight: parseInt(document.getElementById('gridHeight').value),
        difficulty: document.getElementById('difficultySelect').value
      },
      status: 'waiting'
    });

    // EÅŸleÅŸme durumunu dinle
    matchmakingRef.on('value', (snapshot) => {
      const matchData = snapshot.val();
      if (!matchData) return;
      
      if (matchData.status === 'matched' && matchData.gameId) {
        // EÅŸleÅŸme bulundu
        joinOnlineGame(matchData.gameId, matchData.playerRole);
      } else if (matchData.status === 'timeout') {
        // Zaman aÅŸÄ±mÄ±
        matchStatusText.textContent = "EÅŸleÅŸme bulunamadÄ±. Tekrar deneyin.";
        findMatchBtn.disabled = false;
        matchmakingRef.remove();
        clearTimeout(matchTimeout);
      }
    });

    // EÅŸleÅŸme bulmaya Ã§alÄ±ÅŸ (30 saniye iÃ§inde)
    matchTimeout = setTimeout(() => {
      matchmakingRef.transaction((currentData) => {
        if (currentData && currentData.status === 'waiting') {
          currentData.status = 'timeout';
        }
        return currentData;
      });
    }, 30000);

    // Uygun eÅŸleÅŸme ara
    database.ref('matchmaking').orderByChild('status').equalTo('waiting').once('value', (snapshot) => {
      snapshot.forEach((childSnapshot) => {
        const otherPlayer = childSnapshot.val();
        
        if (otherPlayer.playerId !== myPlayerId && otherPlayer.status === 'waiting') {
          // EÅŸleÅŸme bulundu, oyun oluÅŸtur
          const gameId = generateGameId();
          const gameRef = database.ref(`games/${gameId}`);
          
          // Oyunu baÅŸlat (ilk oyuncunun ayarlarÄ±nÄ± kullan)
          gameRef.set({
            player1: otherPlayer.playerId,
            player2: myPlayerId,
            status: 'waiting',
            config: otherPlayer.config, // Ä°lk oyuncunun ayarlarÄ±
            currentPlayer: 'player1',
            createdAt: firebase.database.ServerValue.TIMESTAMP
          });

          // Her iki oyuncuya da bilgi ver
          database.ref(`matchmaking/${childSnapshot.key}`).update({
            gameId: gameId,
            playerRole: 'player1',
            status: 'matched'
          });
          
          matchmakingRef.update({
            gameId: gameId,
            playerRole: 'player2',
            status: 'matched'
          });
          
          // EÅŸleÅŸme kayÄ±tlarÄ±nÄ± temizle
          setTimeout(() => {
            database.ref(`matchmaking/${childSnapshot.key}`).remove();
            matchmakingRef.remove();
          }, 5000);
          
          return true; // DÃ¶ngÃ¼yÃ¼ sonlandÄ±r
        }
      });
    });
  }

  function joinOnlineGame(gameId, role) {
    playerRole = role;
    currentGameRef = database.ref(`games/${gameId}`);
    
    matchStatusText.textContent = `EÅŸleÅŸme bulundu! Oyun ID: ${gameId}`;
    matchProgress.style.display = 'none';
    
    currentGameRef.on('value', (snapshot) => {
      const game = snapshot.val();
      if (!game) return;
  // BURAYA EK: obstacles henÃ¼z hazÄ±r deÄŸilse bekle
  if (game.status === 'playing' && (!game.obstacles || Object.keys(game.obstacles).length === 0)) {
    return; // obstacles henÃ¼z hazÄ±r deÄŸil
  }

  startOnlineGame(game);

  if (game.moves) {
    processOnlineMoves(game.moves);
  }

  if (game.winner) {
    showOnlineResult(game.winner);
      }
    });
  }

  function startOnlineGame(gameData) {
    isOnlineGame = true;
    gameActive = true;
    
    // Grid boyutlarÄ±nÄ± ve zorluÄŸu ayarla
    gridW = gameData.config.gridWidth;
    gridH = gameData.config.gridHeight;
    difficultySelect.value = gameData.config.difficulty;
    
    // UI gÃ¼ncellemeleri
    document.getElementById('gridWidth').value = gridW;
    document.getElementById('gridHeight').value = gridH;
    
    // Engel ve kilitli noktalarÄ± senkronize et
    obstacles = gameData.obstacles || [];
    
    // Kimin sÄ±rasÄ± olduÄŸunu belirle
    currentPlayer = gameData.currentPlayer === 'player1' ? 1 : 2;
    
    resizeCanvas();
    updateOnlineStatus(`Oyun baÅŸladÄ±! (SÄ±ra: ${currentPlayer === 1 ? 'Sen' : 'Rakip'})`, playerRole);
  }

  function sendOnlineMove(move) {
    currentGameRef.child('moves').push({
      ...move,
      timestamp: firebase.database.ServerValue.TIMESTAMP
    });
    
    // SÄ±rayÄ± deÄŸiÅŸtir
    const nextPlayer = playerRole === 'player1' ? 'player2' : 'player1';
    currentGameRef.update({
      currentPlayer: nextPlayer
    });
  }

  function processOnlineMoves(moves) {
    Object.entries(moves).forEach(([moveId, move]) => {
      if (!isMoveProcessed(move)) {
        processMoveLocally(move);
      }
    });
  }

  function isMoveProcessed(move) {
    return edges.some(e => 
      e.from.x === move.from.x && e.from.y === move.from.y &&
      e.to.x === move.to.x && e.to.y === move.to.y &&
      e.player === move.player
    );
  }

  function endOnlineGame(winner) {
    const winnerText = winner === 1 ? 
      (playerRole === 'player1' ? "Tebrikler KazandÄ±nÄ±z!" : "Maalesef Kaybettiniz!") :
      (playerRole === 'player2' ? "Tebrikler KazandÄ±nÄ±z!" : "Maalesef Kaybettiniz!");
    
    currentGameRef.update({ 
      winner: winner,
      status: 'finished',
      endedAt: firebase.database.ServerValue.TIMESTAMP
    }).then(() => {
      showWinner(winner, winnerText);
      cleanupOnlineGame();
    });
  }

  function showOnlineResult(winner) {
    const isWinner = winner === (playerRole === 'player1' ? 1 : 2);
    if (isWinner) {
      winnerText.textContent = "Tebrikler KazandÄ±nÄ±z!";
      winnerModal.style.display = 'flex';
    } else {
      loserText.textContent = "Maalesef Kaybettiniz!";
      loserModal.style.display = 'flex';
    }
    cleanupOnlineGame();
  }

  function cleanupOnlineGame() {
    if (currentGameRef) {
      currentGameRef.off();
      currentGameRef = null;
    }
    if (matchmakingRef) {
      matchmakingRef.off();
      matchmakingRef.remove();
      matchmakingRef = null;
    }
    if (matchTimeout) {
      clearTimeout(matchTimeout);
    }
    isOnlineGame = false;
    playerRole = null;
    updateOnlineStatus('', '');
    findMatchBtn.disabled = false;
    matchStatus.style.display = 'none';
    matchProgress.style.display = 'block';
  }

  function updateOnlineStatus(text, role) {
    const statusElement = document.getElementById('onlineStatus');
    const textElement = document.getElementById('gameStatusText');
    const badgeElement = document.getElementById('playerRoleBadge');
    
    textElement.textContent = text;
    badgeElement.textContent = role === 'player1' ? 'Oyuncu 1' : 'Oyuncu 2';
    badgeElement.className = 'badge ' + (role === 'player1' ? 'player1-badge' : 'player2-badge');
    
    statusElement.style.display = text ? 'block' : 'none';
  }

  function generateGameId() {
    return 'game-' + Math.random().toString(36).substr(2, 8);
  }

  function showWinner(winner, text) {
    if (winner === 1) {
      winnerText.textContent = text;
      winnerModal.style.display = 'flex';
    } else {
      loserText.textContent = text;
      loserModal.style.display = 'flex';
    }
  }

  // BaÄŸlantÄ± kontrolÃ¼
  function setupConnectionMonitoring() {
    const connectedRef = database.ref(".info/connected");
    connectedRef.on("value", (snap) => {
      if (snap.val() === false) {
        // BaÄŸlantÄ± kesildi
        if (isOnlineGame && gameActive) {
          endOnlineGame(playerRole === 'player1' ? 2 : 1);
        }
        if (matchmakingRef) {
          matchmakingRef.remove();
        }
      }
    });
  }

  // Oyun baÅŸlatma
  function startGame() {
    const mode = modeSelect.value;
    
    gridW = parseInt(document.getElementById('gridWidth').value);
    gridH = parseInt(document.getElementById('gridHeight').value);
    edges = [];
    lastPoint = null;
    gameActive = true;
    
    if (mode !== 'online') {
      generateObstacles();
      currentPlayer = mode === 'robot' ? 2 : 1; // Robot modunda robot baÅŸlasÄ±n
      if (mode === 'robot' && currentPlayer === 2) {
        setTimeout(robotMove, 500);
      }
    }
    
    winnerModal.style.display = 'none';
    loserModal.style.display = 'none';
    resizeCanvas();
  }

  // Mod seÃ§imi deÄŸiÅŸtiÄŸinde
  modeSelect.addEventListener('change', function() {
    if (this.value === 'online') {
      document.getElementById('onlinePanel').style.display = 'block';
      document.getElementById('firstMoveHelp').style.display = 'none';
      document.getElementById('findMatchBtn').disabled = false;
      document.getElementById('matchStatus').style.display = 'none';
    } else {
      document.getElementById('onlinePanel').style.display = 'none';
      document.getElementById('firstMoveHelp').style.display = 'block';
      if (currentGameRef) {
        cleanupOnlineGame();
      }
      if (matchmakingRef) {
        matchmakingRef.remove();
        matchmakingRef = null;
      }
    }
  });

  // EÅŸleÅŸme butonu
  findMatchBtn.addEventListener('click', findOnlineMatch);

  // Sayfa yÃ¼klendiÄŸinde
  window.addEventListener('DOMContentLoaded', function() {
    initTutorial();
    if (modeSelect.value !== 'online') { startGame(); }
    startGame();
    setupConnectionMonitoring();
  });
  
  window.addEventListener('resize', resizeCanvas);

  // Ã–ÄŸretici fonksiyonlarÄ±
  function initTutorial() {
    const tutorialModal = document.getElementById('tutorialModal');
    const closeTutorial = document.getElementById('closeTutorial');
    const prevBtn = document.getElementById('prevStep');
    const nextBtn = document.getElementById('nextStep');
    const skipBtn = document.getElementById('skipTutorial');
    const steps = document.querySelectorAll('.tutorial-step');
    let currentStep = 1;

    // Ã–ÄŸretici canvaslarÄ±nÄ± Ã§iz
    drawTutorialCanvases();

    closeTutorial.addEventListener('click', () => {
      tutorialModal.style.display = 'none';
    });

    nextBtn.addEventListener('click', () => {
      if (currentStep < steps.length) {
        document.querySelector(`.tutorial-step[data-step="${currentStep}"]`).style.display = 'none';
        currentStep++;
        document.querySelector(`.tutorial-step[data-step="${currentStep}"]`).style.display = 'block';
        prevBtn.disabled = currentStep === 1;
        nextBtn.textContent = currentStep === steps.length ? 'Bitir' : 'Sonraki';
      } else {
        tutorialModal.style.display = 'none';
      }
    });

    prevBtn.addEventListener('click', () => {
      if (currentStep > 1) {
        document.querySelector(`.tutorial-step[data-step="${currentStep}"]`).style.display = 'none';
        currentStep--;
        document.querySelector(`.tutorial-step[data-step="${currentStep}"]`).style.display = 'block';
        prevBtn.disabled = currentStep === 1;
        nextBtn.textContent = 'Sonraki';
      }
    });

    skipBtn.addEventListener('click', () => {
      tutorialModal.style.display = 'none';
    });
  }

  function drawTutorialCanvases() {
    const canvas1 = document.getElementById('tutorialCanvas1');
    const ctx1 = canvas1.getContext('2d');
    drawTutorialGrid(ctx1, canvas1.width, canvas1.height);
    drawTutorialPoint(ctx1, 0, 4, '#34A853');
    drawTutorialPoint(ctx1, 5, 0, '#EA4335');

    const canvas2 = document.getElementById('tutorialCanvas2');
    const ctx2 = canvas2.getContext('2d');
    drawTutorialGrid(ctx2, canvas2.width, canvas2.height);
    drawTutorialPoint(ctx2, 0, 4, '#34A853');
    drawTutorialPoint(ctx2, 5, 0, '#EA4335');
    drawTutorialPoint(ctx2, 0, 3, '#4285F4', true);
    drawTutorialPoint(ctx2, 1, 4, '#4285F4', true);
    drawTutorialLine(ctx2, 0, 4, 1, 4, '#5e35b1');

    const canvas3 = document.getElementById('tutorialCanvas3');
    const ctx3 = canvas3.getContext('2d');
    drawTutorialGrid(ctx3, canvas3.width, canvas3.height);
    drawTutorialPoint(ctx3, 0, 4, '#34A853');
    drawTutorialPoint(ctx3, 5, 0, '#EA4335');
    drawTutorialLine(ctx3, 0, 4, 1, 4, '#5e35b1');
    drawTutorialLine(ctx3, 1, 4, 2, 3, '#5e35b1');
    drawTutorialLine(ctx3, 2, 3, 3, 2, '#5e35b1');
    drawTutorialLine(ctx3, 3, 2, 4, 1, '#5e35b1');
    drawTutorialPoint(ctx3, 4, 1, '#FBBC05');
  }

  function drawTutorialGrid(ctx, width, height) {
    ctx.clearRect(0, 0, width, height);
    const padding = width * 0.1;
    const gridW = 6, gridH = 5;
    
    ctx.strokeStyle = '#e0e0e0';
    ctx.lineWidth = 1;
    
    for (let x = 0; x < gridW; x++) {
      const px = padding + (x * (width - 2*padding)) / (gridW - 1);
      ctx.beginPath();
      ctx.moveTo(px, padding);
      ctx.lineTo(px, height - padding);
      ctx.stroke();
    }
    
    for (let y = 0; y < gridH; y++) {
      const py = padding + (y * (height - 2*padding)) / (gridH - 1);
      ctx.beginPath();
      ctx.moveTo(padding, py);
      ctx.lineTo(width - padding, py);
      ctx.stroke();
    }
  }

  function drawTutorialPoint(ctx, x, y, color, isHollow = false) {
    const padding = ctx.canvas.width * 0.1;
    const px = padding + (x * (ctx.canvas.width - 2*padding)) / 5;
    const py = padding + (y * (ctx.canvas.height - 2*padding)) / 4;
    
    ctx.beginPath();
    ctx.arc(px, py, 10, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    
    if (isHollow) {
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }

  function drawTutorialLine(ctx, x1, y1, x2, y2, color) {
    const padding = ctx.canvas.width * 0.1;
    const p1x = padding + (x1 * (ctx.canvas.width - 2*padding)) / 5;
    const p1y = padding + (y1 * (ctx.canvas.height - 2*padding)) / 4;
    const p2x = padding + (x2 * (ctx.canvas.width - 2*padding)) / 5;
    const p2y = padding + (y2 * (ctx.canvas.height - 2*padding)) / 4;
    
    ctx.beginPath();
    ctx.moveTo(p1x, p1y);
    ctx.lineTo(p2x, p2y);
    ctx.strokeStyle = color;
    ctx.lineWidth = 4;
    ctx.stroke();
  }

  // DiÄŸer event listener'lar
  startButton.addEventListener('click', () => {
    if (modeSelect.value !== 'online') {
      startGame();
    }
  });
  playAgainBtn.addEventListener('click', startGame);
  tryAgainBtn.addEventListener('click', startGame);
  helpButton.addEventListener('click', () => helpModal.style.display = 'flex');
  closeModal.addEventListener('click', () => helpModal.style.display = 'none');
</script>
</body>
</html>


<script>
function isVictory(p) {
  return p.x === gridW - 1 && p.y === 0;
}

function getAvailableMoves(from) {
  const moves = [];
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      if (dx === 0 && dy === 0) continue;
      const nx = from.x + dx;
      const ny = from.y + dy;
      if (nx >= 0 && ny >= 0 && nx < gridW && ny < gridH) {
        const next = { x: nx, y: ny };
        if (!edgeExists(from, next) && !isObstacle(next)) {
          moves.push(next);
        }
      }
    }
  }
  return moves;
}

function getMediumMove(from) {
  const options = getAvailableMoves(from);
  const goal = { x: gridW - 1, y: 0 };

  return options.reduce((best, move) => {
    const dist = Math.hypot(goal.x - move.x, goal.y - move.y);
    const score = dist + Math.random() * 2;
    return !best || score < best.score ? { move, score } : best;
  }, null)?.move || null;
}

function getHardMove(from) {
  const options = getAvailableMoves(from);
  const goal = { x: gridW - 1, y: 0 };

  let bestMove = null;
  let bestScore = -Infinity;

  for (const move of options) {
    edges.push({ from, to: move, player: 2 });
    const playerOptions = getAvailableMoves(move);
    edges.pop();

    const dist = Math.hypot(goal.x - move.x, goal.y - move.y);
    let score = -dist;
    score -= playerOptions.length * 3;

    if (score > bestScore) {
      bestScore = score;
      bestMove = move;
    }
  }
  return bestMove || options[0];
}

function getExpertMove(from) {
  const options = getAvailableMoves(from);
  if (options.length === 0) return null;

  let bestMove = null;
  let bestScore = -Infinity;
  const goal = { x: gridW - 1, y: 0 };

  for (const move of options) {
    edges.push({ from, to: move, player: 2 });
    const playerMoves = getAvailableMoves(move);

    let totalScore = 0;
    let loseImmediately = false;

    if (playerMoves.length === 0) {
      edges.pop();
      return move;
    }

    for (const pMove of playerMoves) {
      edges.push({ from: move, to: pMove, player: 1 });

      if (isVictory(pMove)) {
        loseImmediately = true;
        edges.pop();
        break;
      }

      const robotReplies = getAvailableMoves(pMove);

      for (const reply of robotReplies) {
        edges.push({ from: pMove, to: reply, player: 2 });
        const playerOptions = getAvailableMoves(reply);

        let score = 0;
        if (playerOptions.length === 0) score += 1000;
        if (isVictory(reply)) score += 500;
        score -= Math.hypot(goal.x - reply.x, goal.y - reply.y) * 2;
        score -= playerOptions.length * 10;

        totalScore += score;
        edges.pop();
      }

      edges.pop();
    }

    edges.pop();

    if (loseImmediately) continue;

    if (totalScore > bestScore) {
      bestScore = totalScore;
      bestMove = move;
    }
  }

  return bestMove;
}

function getBestMove(from) {
  const settings = {
    easy: { mistakeRate: 0.5 },
    medium: { mistakeRate: 0.3 },
    hard: { mistakeRate: 0.04 },
    expert: { mistakeRate: 0.0001 }
  }[difficultySelect.value];

  if (Math.random() < settings.mistakeRate) {
    const options = getAvailableMoves(from);
    return options.length > 0 ? options[Math.floor(Math.random() * options.length)] : null;
  }

  switch (difficultySelect.value) {
    case 'expert': return getExpertMove(from);
    case 'hard': return getHardMove(from);
    case 'medium': return getMediumMove(from);
    default:
      const options = getAvailableMoves(from);
      return options.length > 0 ? options[Math.floor(Math.random() * options.length)] : null;
  }
}

function robotMove() {
  if (!gameActive || modeSelect.value !== "robot") return;
  const move = getBestMove(lastPoint);
  if (move) {
    makeMove(move);
  } else {
    endGame(1);
  }
}
</script>





<script>
function toggleStatsPopup() {
  const popup = document.getElementById("statsPopup");
  popup.style.display = popup.style.display === "none" ? "block" : "none";
}

function loadStats() {
  const wins = parseInt(localStorage.getItem("vectoryWins") || 0);
  const losses = parseInt(localStorage.getItem("vectoryLosses") || 0);
  const games = wins + losses;
  const winRate = games > 0 ? ((wins / games) * 100).toFixed(1) + "%" : "0%";

  document.getElementById("wins").textContent = wins;
  document.getElementById("losses").textContent = losses;
  document.getElementById("gamesPlayed").textContent = games;
  document.getElementById("winRate").textContent = winRate;
}

function updateStats(winner) {
  if (winner === 2) {
    const wins = parseInt(localStorage.getItem("vectoryWins") || 0) + 1;
    localStorage.setItem("vectoryWins", wins);
  } else if (winner === 1) {
    const losses = parseInt(localStorage.getItem("vectoryLosses") || 0) + 1;
    localStorage.setItem("vectoryLosses", losses);
  }
  loadStats();
}

const originalEndGame = window.endGame;
window.endGame = function(winner) {
  updateStats(winner);
  if (originalEndGame) originalEndGame(winner);
};

window.addEventListener("load", loadStats);
</script>


<!-- ðŸ“Š Ä°statistik GÃ¶ster Butonu -->
<button onclick="toggleStatsPopup()" style="position: absolute; top: 10px; left: 10px; z-index: 1000;">ðŸ“Š Ä°statistik</button>

<!-- Popup Panel -->
<div id="statsPopup" style="display:none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
background: white; border: 2px solid #444; padding: 20px; z-index: 1001; box-shadow: 0 0 10px rgba(0,0,0,0.5); border-radius: 10px;">
  <h3>Ä°statistikler</h3>
  <p>KazanÃ§: <span id="wins">0</span></p>
  <p>KayÄ±p: <span id="losses">0</span></p>
  <p>Oynanan Oyun: <span id="gamesPlayed">0</span></p>
  <p>Kazanma OranÄ±: <span id="winRate">0%</span></p>
  <button onclick="toggleStatsPopup()">Kapat</button>
</div>

<style>
@media (max-width: 600px) {
  #statsPopup {
    width: 90%;
    font-size: 14px;
  }
}
</style>


<script>
function toggleStatsPopup() {
  const popup = document.getElementById("statsPopup");
  popup.style.display = popup.style.display === "none" ? "block" : "none";
}

function loadStats() {
  const wins = parseInt(localStorage.getItem("vectoryWins") || 0);
  const losses = parseInt(localStorage.getItem("vectoryLosses") || 0);
  const games = wins + losses;
  const winRate = games > 0 ? ((wins / games) * 100).toFixed(1) + "%" : "0%";

  document.getElementById("wins").textContent = wins;
  document.getElementById("losses").textContent = losses;
  document.getElementById("gamesPlayed").textContent = games;
  document.getElementById("winRate").textContent = winRate;
}

function updateStats(winner) {
  if (winner === 2) {
    const wins = parseInt(localStorage.getItem("vectoryWins") || 0) + 1;
    localStorage.setItem("vectoryWins", wins);
  } else if (winner === 1) {
    const losses = parseInt(localStorage.getItem("vectoryLosses") || 0) + 1;
    localStorage.setItem("vectoryLosses", losses);
  }
  loadStats();
}

const originalEndGame = window.endGame;
window.endGame = function(winner) {
  updateStats(winner);
  if (originalEndGame) originalEndGame(winner);
};

window.addEventListener("load", loadStats);
</script>



<script>
// Canvas tÄ±klama ve dokunma desteÄŸi
canvas.addEventListener("click", handleCanvasClick);
canvas.addEventListener("touchstart", function(e) {
  const rect = canvas.getBoundingClientRect();
  const touch = e.touches[0];
  const x = touch.clientX - rect.left;
  const y = touch.clientY - rect.top;
  handleCanvasEvent(x, y);
});

function handleCanvasClick(e) {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  handleCanvasEvent(x, y);
}

// Bu fonksiyon tÄ±klanan veya dokunulan grid noktasÄ±nÄ± bulup iÅŸleme sokar
function handleCanvasEvent(x, y) {
  const cellWidth = canvas.width / gridW;
  const cellHeight = canvas.height / gridH;
  const cx = Math.floor(x / cellWidth);
  const cy = Math.floor(y / cellHeight);
  handleClick(cx, cy);
}
</script>
