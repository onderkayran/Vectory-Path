<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Vectory Path</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet"/>
<style>
    body {
      background-color: #f5f6fa;
      padding: 20px;
    }
    .game-container {
      max-width: 500px;
      margin: 0 auto;
      background-color: #ffffff;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }
    
    canvas {
      border: 2px solid #e0e0e0;
      background-color: #e6f7f5;
      display: block;
      margin: 0 auto 20px auto;
      width: 100%;
      max-width: 450px;
      height: 450px;
    }

    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0,0,0,0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background-color: white;
      padding: 25px;
      border-radius: 10px;
      max-width: 500px;
      width: 90%;
      position: relative;
    }
    .close-modal {
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 24px;
      cursor: pointer;
      color: #777;
    }
    .winner-modal {
      background-color: #34A853;
      color: white;
      text-align: center;
    }
    .loser-modal {
      background-color: #EA4335;
      color: white;
      text-align: center;
    }
    .obstacle-point {
      position: absolute;
      font-weight: bold;
      color: #000;
    }
    .tutorial-canvas-container {
      border: 2px solid #eee;
      border-radius: 8px;
      margin: 0 auto;
      width: fit-content;
    }
    .tutorial-step {
      transition: all 0.3s ease;
    }
    .tutorial-nav-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 20px;
    }
    .highlight-point {
      animation: pulse 1s infinite;
      box-shadow: 0 0 15px #FBBC05;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    #onlineStatus {
      display: none;
      margin-top: 10px;
    }
    #matchStatus {
      display: none;
      margin-top: 10px;
    }
    .player-badge {
      font-size: 0.8rem;
      padding: 3px 6px;
      border-radius: 4px;
    }
    .player1-badge {
      background-color: #EA4335;
      color: white;
    }
    .player2-badge {
      background-color: #5e35b1;
      color: white;
    }
    #matchProgress {
      margin-top: 10px;
      height: 5px;
    }
  
@media (max-width: 600px) {
  .game-container {
    padding: 10px;
  }
  
    canvas {
      border: 2px solid #e0e0e0;
      background-color: #e6f7f5;
      display: block;
      margin: 0 auto 20px auto;
      width: 100%;
      max-width: 450px;
      height: 450px;
    }

  .d-flex.flex-wrap {
    flex-direction: column;
    align-items: center;
  }
  .d-flex.flex-wrap button,
  .d-flex.flex-wrap select,
  .d-flex.flex-wrap input {
    width: 90% !important;
    margin-bottom: 8px;
  }
}

</style>

<style>
  @media (max-width: 600px) {
    .modal-content {
      width: 95% !important;
      max-width: 100% !important;
    }
    .tutorial-canvas-container canvas {
      width: 100% !important;
      height: auto !important;
    }
    canvas {
      height: auto !important;
      aspect-ratio: 1 / 1 !important;
    }
  }
</style>

</head>
<body>

<div class="game-container">
<h1 class="text-center fw-bold" style="font-family: 'Poppins', sans-serif; font-size: 2.5rem; color: white; margin-bottom: 20px; background: linear-gradient(to right, #4facfe, #00f2fe); padding: 10px 20px; border-radius: 12px;">
  Vectory Path
</h1>
<canvas id="gameCanvas"></canvas>
<div class="d-flex flex-wrap justify-content-center gap-2 my-3">
<label class="me-2">Grid:</label>
<input class="form-control me-2" id="gridWidth" max="10" min="3" style="width: 60px;" type="number" value="6"/>
<span class="me-2">x</span>
<input class="form-control me-2" id="gridHeight" max="10" min="3" style="width: 60px;" type="number" value="5"/>
<select class="form-select me-2" id="difficultySelect" style="width: 120px;">
<option value="easy">Easy</option>
<option value="medium">Medium</option>
<option value="hard">Hard</option>
<option selected="" value="expert">Expert</option>
</select>
<select class="form-select me-2" id="modeSelect" style="width: 150px;">
<option selected="" value="robot">Play with Robot</option>
<option value="online">Play Online</option>
</select>
<button class="btn btn-primary me-2" id="startButton">Start</button>
<button class="btn btn-info text-white" id="helpButton">Help</button>
<button class="btn btn-secondary" onclick="toggleStatsPopup()">Statistics</button>
<button class="btn btn-dark" onclick="toggleDarkMode()">ðŸŒ™</button>
</div>
<div class="alert alert-warning" id="onlineStatus">
<strong>Online Game:</strong>
<span id="gameStatusText">Connecting...</span>
<span class="badge ms-2" id="playerRoleBadge"></span>
</div>
<div class="alert alert-info mt-3" id="firstMoveHelp" style="font-size: 14px;">
<strong>First Move Tip:</strong><br/>
    Click one of the points adjacent to the bottom-left corner (green dot) to start the game. 
  </div>
<!-- Eklenen: Leave Game Butonu -->
<button class="btn btn-danger w-100 mb-2" id="leaveGameBtn" style="display:none;">Leave Game</button>
<!-- Eklenen: Hamle SÃ¼resi GÃ¶stergesi -->
<div class="alert alert-warning text-center fw-bold" id="turnTimer" style="display:none;">
  Your time: <span id="timeLeft">20</span> seconds
</div>
<div class="mt-4 p-3 border rounded bg-light" id="onlinePanel" style="display: none;">
<h5 class="text-center mb-3 fw-bold">Online Game</h5>
<button class="btn btn-primary w-100 mb-2" id="findMatchBtn">Find Match</button>
<div class="alert alert-info mt-3" id="matchStatus">
<span id="matchStatusText">Searching for match...</span>
<div class="progress" id="matchProgress">
<div class="progress-bar progress-bar-striped progress-bar-animated" style="width: 100%"></div>
</div>
</div>
</div>
</div>
<!-- Help Modal -->
<div class="modal-overlay" id="helpModal">
<div class="modal-content">
<span class="close-modal" id="closeModal">Ã—</span>
<h4 class="text-primary">How to Play?</h4>
<p>The goal of the game is to reach the end point from the starting point.</p>
<ul>
<li>Move by drawing lines between adjacent points.</li>
<li>You can only move to adjacent points (diagonal moves are allowed).</li>
<li>Points marked with X are obstacles and cannot be used.</li>
<li>Points marked with ðŸ”’ are locked and unusable (in 5x5 or larger grids).</li>
<li>The player who blocks the opponent from making a move wins.</li>
</ul>
<h5 class="mt-3">Online Mod:</h5>
<p>You can play with real players via random matchmaking.</p>
</div>
</div>
<!-- Tutorial Modal -->
<div class="modal-overlay" id="tutorialModal" style="display:flex;">
<div class="modal-content" style="max-width:600px;">
<span class="close-modal" id="closeTutorial">Ã—</span>
<h4 class="text-primary mb-4">Vectory Path Tutorial</h4>
<div class="tutorial-step active" data-step="1">
<h5>1. Start and End Points</h5>
<div class="tutorial-canvas-container mb-3">
<canvas height="300" id="tutorialCanvas1" width="400"></canvas>
</div>
<p>The green dot (bottom-left) is the start, the red dot (top-right) is the goal.</p>
</div>
<div class="tutorial-step" data-step="2" style="display:none;">
<h5>2. Your First Move</h5>
<div class="tutorial-canvas-container mb-3">
<canvas height="300" id="tutorialCanvas2" width="400"></canvas>
</div>
<p>Click on the neighbors of the starting point to make your first move.</p>
</div>
<div class="tutorial-step" data-step="3" style="display:none;">
<h5>3. Creating a Path</h5>
<div class="tutorial-canvas-container mb-3">
<canvas height="300" id="tutorialCanvas3" width="400"></canvas>
</div>
<p>Draw lines between adjacent points to reach the goal.</p>
</div>
<div class="d-flex justify-content-between mt-4">
<button class="btn btn-secondary" disabled="" id="prevStep">Previous</button>
<button class="btn btn-primary" id="nextStep">Next</button>
</div>
<button class="btn btn-outline-secondary mt-2 w-100" id="skipTutorial">Skip Tutorial</button>
</div>
</div>
<!-- Winner Modal -->
<div class="modal-overlay" id="winnerModal" style="display:none;">
<div class="modal-content winner-modal">
<h2 id="winnerText" style="background-color: #34A853; color: white; padding: 15px; border-radius: 10px;">Congratulations, You Won!</h2>
<button class="btn btn-light mt-3" id="playAgainBtn">Play Again</button>
</div>
</div>
<!-- Loser Modal -->
<div class="modal-overlay" id="loserModal" style="display:none;">
<div class="modal-content loser-modal">
<h2 id="loserText" style="background-color: #EA4335; color: white; padding: 15px; border-radius: 10px;">Unfortunately, You Lost!</h2>
<button class="btn btn-light mt-3" id="tryAgainBtn">New Game</button>
</div>
</div>
<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
<script>
  // Firebase konfigÃ¼rasyonu
  const firebaseConfig = {
    apiKey: "AIzaSyB4lQ2KZanAK3fzRmwXhedh4rtfb6PZ9FY",
    authDomain: "vectory-path.firebaseapp.com",
    databaseURL: "https://vectory-path-default-rtdb.firebaseio.com",
    projectId: "vectory-path",
    storageBucket: "vectory-path.firebasestorage.app",
    messagingSenderId: "462766360594",
    appId: "1:462766360594:web:9a9443f056d45155c8b0cb",
    measurementId: "G-KCKK8ZRHTT"
  };

  // Firebase baÅŸlatma
  firebase.initializeApp(firebaseConfig);
  const database = firebase.database();

  // Oyun durumu
let hasShownResult = false;
  let gridW = 6, gridH = 5;
  let edges = [];
  let currentPlayer = 1;
  let lastPoint = null;
  let gameActive = true;
  let obstacles = [];
  let currentGameRef = null;
  let isOnlineGame = false;
  let playerRole = null;
  let myPlayerId = Math.random().toString(36).substr(2, 9); // Rastgele oyuncu ID
  let matchmakingRef = null;
  let matchTimeout = null;

  // Canvas ve UI elementleri
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const startButton = document.getElementById('startButton');
  const helpButton = document.getElementById('helpButton');
  const helpModal = document.getElementById('helpModal');
  const closeModal = document.getElementById('closeModal');
  const winnerModal = document.getElementById('winnerModal');
  const winnerText = document.getElementById('winnerText');
  const playAgainBtn = document.getElementById('playAgainBtn');
  const loserModal = document.getElementById('loserModal');
  const loserText = document.getElementById('loserText');
  const tryAgainBtn = document.getElementById('tryAgainBtn');
  const difficultySelect = document.getElementById('difficultySelect');
  const modeSelect = document.getElementById('modeSelect');
  const findMatchBtn = document.getElementById('findMatchBtn');
  const matchStatus = document.getElementById('matchStatus');
  const matchStatusText = document.getElementById('matchStatusText');
  const matchProgress = document.getElementById('matchProgress');

  // Canvas boyutlandÄ±rma
  function resizeCanvas() {
    const container = document.querySelector('.game-container');
    const size = Math.min(container.clientWidth * 0.9, 500);
    canvas.width = size;
    canvas.height = size;
    drawGrid();
  }

  // Grid koordinatlarÄ±nÄ± canvas koordinatlarÄ±na Ã§evir
  function toCanvasCoords(p) {
    const padding = canvas.width * 0.1;
    const usableW = canvas.width - 2 * padding;
    const usableH = canvas.height - 2 * padding;
    return {
      x: Math.round(padding + (p.x * usableW) / (gridW - 1)),
      y: Math.round(padding + (p.y * usableH) / (gridH - 1))
    };
  }

  // Engel oluÅŸtur
  function generateObstacles() {
    obstacles = [];
    const difficulty = difficultySelect.value;
    let obstacleCount;
    
    switch(difficulty) {
      case 'easy': obstacleCount = Math.floor(gridW * gridH * 0.05); break;
      case 'medium': obstacleCount = Math.floor(gridW * gridH * 0.1); break;
      case 'hard': obstacleCount = Math.floor(gridW * gridH * 0.15); break;
      case 'expert': obstacleCount = 0; break;
    }
    
    // Kilitli noktalarÄ± ekle (5x5 ve Ã¼zeri gridlerde)
    if (gridW >= 5 && gridH >= 5) {
      addLockedPoints(4);
    }
    
    const protectedPoints = [
      {x: 0, y: gridH - 1}, {x: gridW - 1, y: 0},
      {x: 0, y: gridH - 2}, {x: 1, y: gridH - 1},
      {x: 1, y: gridH - 2}, {x: gridW - 1, y: 1},
      {x: gridW - 2, y: 0}, {x: gridW - 2, y: 1}
    ];
    
    let attempts = 0;
    while (obstacles.length < obstacleCount && attempts < 100) {
      attempts++;
      const x = Math.floor(Math.random() * gridW);
      const y = Math.floor(Math.random() * gridH);
      
      const isProtected = protectedPoints.some(p => p.x === x && p.y === y);
      const exists = obstacles.some(obs => obs.x === x && obs.y === y);
      
      if (!isProtected && !exists) {
        // Engel eklemeden Ã¶nce yolun mÃ¼mkÃ¼n olduÄŸunu kontrol et
        const tempObstacles = [...obstacles, {x, y}];
        const start = {x: 0, y: gridH - 1};
        const end = {x: gridW - 1, y: 0};
        if (isPathPossible(start, end, tempObstacles)) {
          obstacles.push({x, y});
        }
      }
    }
    
    // Online oyunda engelleri paylaÅŸ
    if (isOnlineGame && playerRole === 'player1' && currentGameRef) {
      currentGameRef.update({ 
        obstacles: obstacles,
        status: 'playing'
      });
    }
  }

  // Kilitli noktalar ekle
  function addLockedPoints(count) {
    const lockedPoints = [];
    const protectedPoints = [
      {x: 0, y: gridH - 1}, {x: gridW - 1, y: 0},
      {x: 0, y: gridH - 2}, {x: 1, y: gridH - 1},
      {x: 1, y: gridH - 2}, {x: gridW - 1, y: 1},
      {x: gridW - 2, y: 0}, {x: gridW - 2, y: 1}
    ];
    
    while (lockedPoints.length < count) {
      const x = Math.floor(Math.random() * gridW);
      const y = Math.floor(Math.random() * gridH);
      
      const isProtected = protectedPoints.some(p => p.x === x && p.y === y);
      const exists = lockedPoints.some(p => p.x === x && p.y === y);
      
      if (!isProtected && !exists) {
        lockedPoints.push({x, y, locked: true});
      }
    }
    
    obstacles.push(...lockedPoints);
  }

  function isPathPossible(start, end, obstacles) {
    const visited = new Set();
    const queue = [start];
    const key = p => `${p.x},${p.y}`;
    
    while (queue.length > 0) {
      const current = queue.shift();
      if (current.x === end.x && current.y === end.y) return true;
      
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = current.x + dx;
          const ny = current.y + dy;
          if (nx >= 0 && ny >= 0 && nx < gridW && ny < gridH) {
            const next = {x: nx, y: ny};
            if (!obstacles.some(o => o.x === nx && o.y === ny) && !visited.has(key(next))) {
              visited.add(key(next));
              queue.push(next);
            }
          }
        }
      }
    }
    return false;
  }

  // Grid Ã§iz
  function drawGrid() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const padding = canvas.width * 0.1;
    const usableW = canvas.width - 2 * padding;
    const usableH = canvas.height - 2 * padding;

    // Ã‡izgileri Ã§iz
    ctx.lineWidth = 4;
    for (let edge of edges) {
      const from = toCanvasCoords(edge.from);
      const to = toCanvasCoords(edge.to);
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);
      ctx.strokeStyle = edge.player === 1 ? "#EA4335" : "#5e35b1";
      ctx.stroke();
    }

    // NoktalarÄ± Ã§iz
    for (let y = 0; y < gridH; y++) {
      for (let x = 0; x < gridW; x++) {
        const point = {x, y};
        const isObstacle = obstacles.some(obs => obs.x === x && obs.y === y && !obs.locked);
        const isLocked = obstacles.some(obs => obs.x === x && obs.y === y && obs.locked);
        const {x: px, y: py} = toCanvasCoords(point);
        
        if (isLocked) {
          // Kilitli noktalarÄ± Ã¶zel iÅŸaretle
          ctx.beginPath();
          ctx.arc(px, py, 8, 0, Math.PI * 2);
          ctx.fillStyle = "#FF5733";
          ctx.fill();
          ctx.font = 'bold 12px Arial';
          ctx.fillStyle = "#000";
          ctx.fillText('ðŸ”’', px - 6, py + 5);
          continue;
        }
        
        if (isObstacle) {
          ctx.font = 'bold 16px Arial';
          ctx.fillStyle = '#000';
          ctx.fillText('X', px - 5, py + 5);
          continue;
        }
        
        ctx.beginPath();
        ctx.arc(px, py, 8, 0, Math.PI * 2);
        
        if (x === 0 && y === gridH - 1) {
          ctx.fillStyle = "#34A853";
        } else if (x === gridW - 1 && y === 0) {
          ctx.fillStyle = "#EA4335";
        } else if (lastPoint && x === lastPoint.x && y === lastPoint.y) {
          ctx.fillStyle = "#FBBC05";
        } else {
          ctx.fillStyle = "#4285F4";
        }
        ctx.fill();
      }
    }
  }

  // Ä°ki nokta komÅŸu mu kontrolÃ¼
  function isAdjacent(p1, p2) {
    const dx = Math.abs(p1.x - p2.x);
    const dy = Math.abs(p1.y - p2.y);
    return (dx <= 1 && dy <= 1) && !(dx === 0 && dy === 0);
  }

  // Ã‡izgi var mÄ± kontrolÃ¼
  function edgeExists(p1, p2) {
    return edges.some(e =>
      (e.from.x === p1.x && e.from.y === p1.y && e.to.x === p2.x && e.to.y === p2.y) ||
      (e.to.x === p1.x && e.to.y === p1.y && e.from.x === p2.x && e.from.y === p2.y)
    );
  }

  // Engel kontrolÃ¼
  function isObstacle(p) {
    return obstacles.some(obs => obs.x === p.x && obs.y === p.y);
  }

  // Kilitli nokta kontrolÃ¼
  function isLocked(p) {
    return obstacles.some(obs => obs.x === p.x && obs.y === p.y && obs.locked);
  }

  // BitiÅŸ noktasÄ± kontrolÃ¼
  function isEndPoint(p) {
    return p.x === gridW - 1 && p.y === 0;
  }

  // Hamle yapabilme durumunu kontrol et
  function canMove(from) {
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        const nx = from.x + dx;
        const ny = from.y + dy;
        if (nx >= 0 && ny >= 0 && nx < gridW && ny < gridH) {
          const next = { x: nx, y: ny };
          if (!edgeExists(from, next) && !isObstacle(next)) {
            return true;
          }
        }
      }
    }
    return false;
  }

  // Hamle yap
  function makeMove(point) {
  if (!lastPoint) {
    const start = { x: 0, y: gridH - 1 };
    if (!isAdjacent(start, point) || edgeExists(start, point) || isObstacle(point)) return;
  } else {
    if (!isAdjacent(lastPoint, point) || edgeExists(lastPoint, point) || isObstacle(point)) return;
  }
if (!gameActive || isLocked(point)) return;

    const move = {
      from: lastPoint || { x: 0, y: gridH - 1 },
      to: point,
      player: currentPlayer
    };

    if (isOnlineGame) {
      sendOnlineMove(move);
    } else if (modeSelect.value === 'robot' && currentPlayer === 2) {
      setTimeout(robotMove, 500);
    }
    
    processMoveLocally(move);
  }

  function processMoveLocally(move) {
    edges.push({
      from: move.from,
      to: move.to,
      player: move.player
    });
    
    lastPoint = move.to;
    currentPlayer = move.player === 1 ? 2 : 1;
    drawGrid();
    
    if (isEndPoint(move.to)) {
      endGame(move.player);
    } else if (!canMove(lastPoint)) {
  endGame(move.player);
}
  }

  function endGame(winner) {
    gameActive = false;

    if (isOnlineGame) {
      endOnlineGame(winner);
    } else {
      if (modeSelect.value === 'robot') {
        if (winner === 2) {
            winnerText.textContent = "Congratulations, You Won!";
            winnerModal.style.display = 'flex';
        } else {
            loserText.textContent = "Unfortunately, You Lost!";
            loserModal.style.display = 'flex';
        }
    } else if (winner === 1) {
        winnerText.textContent = "Congratulations, You Won!";
        winnerModal.style.display = 'flex';
        winnerModal.style.display = 'flex';
      } else {
        loserText.textContent = modeSelect.value === 'robot' ? "Unfortunately, You Lost!" : "Congratulations, You Won!";
        loserModal.style.display = 'flex';
      }
    }
  }

  // Robot hamlesi
  function robotMove() {
    if (!gameActive || modeSelect.value !== "robot") return;
    
    const endPoint = { x: gridW - 1, y: 0 };
    const difficulty = difficultySelect.value;
    
    // 1. Ã–ncelik: Oyuncuyu hamlesiz bÄ±rakarak kazanma
    const blockingMoves = findBlockingMoves();
    if (blockingMoves.length > 0 && (difficulty === 'hard' || difficulty === 'expert')) {
      makeMove(blockingMoves[0]);
      return;
    }
    
    // 2. Ã–ncelik: BitiÅŸ noktasÄ±na ulaÅŸma fÄ±rsatÄ± varsa ulaÅŸ
    if (isAdjacent(lastPoint, endPoint) && !edgeExists(lastPoint, endPoint)) {
      makeMove(endPoint);
      return;
    }
    
    // 3. Zorluk seviyesine gÃ¶re strateji
    if (difficulty === 'easy') {
      // Rastgele hamle
      const moves = [];
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = lastPoint.x + dx;
          const ny = lastPoint.y + dy;
          if (nx >= 0 && ny >= 0 && nx < gridW && ny < gridH) {
            const next = { x: nx, y: ny };
            if (!edgeExists(lastPoint, next) && !isObstacle(next)) {
              moves.push(next);
            }
          }
        }
      }
      if (moves.length > 0) {
        const randomMove = moves[Math.floor(Math.random() * moves.length)];
        makeMove(randomMove);
        return;
      }
    } else if (difficulty === 'medium') {
      // %50 rastgele, %50 stratejik hamle
      if (Math.random() > 0.5) {
        const moves = [];
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = lastPoint.x + dx;
            const ny = lastPoint.y + dy;
            if (nx >= 0 && ny >= 0 && nx < gridW && ny < gridH) {
              const next = { x: nx, y: ny };
              if (!edgeExists(lastPoint, next) && !isObstacle(next)) {
                moves.push(next);
              }
            }
          }
        }
        if (moves.length > 0) {
          const randomMove = moves[Math.floor(Math.random() * moves.length)];
          makeMove(randomMove);
          return;
        }
      }
    }
    
    // 4. Stratejik hamleler
    const moves = [];
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        const nx = lastPoint.x + dx;
        const ny = lastPoint.y + dy;
        if (nx >= 0 && ny >= 0 && nx < gridW && ny < gridH) {
          const next = { x: nx, y: ny };
          if (!edgeExists(lastPoint, next) && !isObstacle(next)) {
            let priority = 0;
            const distToEnd = Math.abs(nx - endPoint.x) + Math.abs(ny - endPoint.y);
            priority -= distToEnd * 2;
            
            if (difficulty === 'hard' || difficulty === 'expert') {
              const path = findPath(next, endPoint);
              if (path) priority -= path.length * 2;
            }
            
            moves.push({ point: next, priority });
          }
        }
      }
    }
    
    if (moves.length > 0) {
      moves.sort((a, b) => b.priority - a.priority);
      makeMove(moves[0].point);
    } else {
      endGame(1); // Oyuncu kazanÄ±r
    }
  }

  function findBlockingMoves() {
    const blockingMoves = [];
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        const nx = lastPoint.x + dx;
        const ny = lastPoint.y + dy;
        if (nx >= 0 && ny >= 0 && nx < gridW && ny < gridH) {
          const next = { x: nx, y: ny };
          if (!edgeExists(lastPoint, next) && !isObstacle(next)) {
            const tempEdges = [...edges, {from: lastPoint, to: next, player: 2}];
            if (!canMove(next)) {
              blockingMoves.push(next);
            }
          }
        }
      }
    }
    return blockingMoves;
  }

  function findPath(from, to) {
    const visited = new Set();
    const queue = [{ point: from, path: [] }];
    const key = p => `${p.x},${p.y}`;
    
    while (queue.length > 0) {
      const current = queue.shift();
      if (visited.has(key(current.point))) continue;
      visited.add(key(current.point));
      
      if (current.point.x === to.x && current.point.y === to.y) {
        return current.path;
      }
      
      // Ã–nce dÃ¼z (yatay/dikey) komÅŸularÄ± ekle
      const directions = [
        {dx: 1, dy: 0}, {dx: -1, dy: 0}, {dx: 0, dy: 1}, {dx: 0, dy: -1},
        {dx: 1, dy: 1}, {dx: 1, dy: -1}, {dx: -1, dy: 1}, {dx: -1, dy: -1}
      ];
      
      for (const dir of directions) {
        const nx = current.point.x + dir.dx;
        const ny = current.point.y + dir.dy;
        
        if (nx >= 0 && ny >= 0 && nx < gridW && ny < gridH && !isObstacle({x: nx, y: ny})) {
          const nextPoint = { x: nx, y: ny };
          const edgeExists = edges.some(e =>
            (e.from.x === current.point.x && e.from.y === current.point.y && 
             e.to.x === nextPoint.x && e.to.y === nextPoint.y) ||
            (e.to.x === current.point.x && e.to.y === current.point.y && 
             e.from.x === nextPoint.x && e.from.y === nextPoint.y)
          );
          
          if (!edgeExists) {
            const newPath = [...current.path, nextPoint];
            queue.push({ point: nextPoint, path: newPath });
          }
        }
      }
    }
    
    return null;
  }

  // TÄ±klama iÅŸleyici
  canvas.addEventListener("click", function(e) {



    if (!gameActive || (isOnlineGame && currentPlayer !== (playerRole === 'player1' ? 1 : 2))) return;

    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    
    let minDist = Infinity;
    let closestPoint = null;
    
    for (let y = 0; y < gridH; y++) {
      for (let x = 0; x < gridW; x++) {
        if (isObstacle({x, y})) continue;
        
        const canvasCoords = toCanvasCoords({x, y});
        const dist = Math.sqrt(Math.pow(mx - canvasCoords.x, 2) + Math.pow(my - canvasCoords.y, 2));
        
        if (dist < minDist && dist < 20) {
          minDist = dist;
          closestPoint = {x, y};
        }
      }
    }
    
    if (!closestPoint) return;
    const clicked = closestPoint;
    
    const startPoint = { x: 0, y: gridH - 1 };

    if (isEndPoint(clicked)) {
      if (lastPoint && isAdjacent(lastPoint, clicked) && !isObstacle(clicked)) {
        makeMove(clicked);
      }
      return;
    }

    if (!lastPoint) {
      if (isAdjacent(startPoint, clicked) && !edgeExists(startPoint, clicked) && !isObstacle(clicked)) {
        makeMove(clicked);
      }
      return;
    }

    if (isAdjacent(lastPoint, clicked) && !edgeExists(lastPoint, clicked) && !isObstacle(clicked)) {
      makeMove(clicked);
    }
  });

  // Online oyun fonksiyonlarÄ±
  function findOnlineMatch() {
    matchStatus.style.display = 'block';
    matchStatusText.textContent = "Searching for match...";
    findMatchBtn.disabled = true;
    
    // EÅŸleÅŸme kuyruÄŸuna ekle
    matchmakingRef = database.ref('matchmaking').push({
      playerId: myPlayerId,
      timestamp: firebase.database.ServerValue.TIMESTAMP,
      config: {
        gridWidth: parseInt(document.getElementById('gridWidth').value),
        gridHeight: parseInt(document.getElementById('gridHeight').value),
        difficulty: document.getElementById('difficultySelect').value
      },
      status: 'waiting'
    });

    // EÅŸleÅŸme durumunu dinle
    matchmakingRef.on('value', (snapshot) => {
      const matchData = snapshot.val();
      if (!matchData) return;
      
      if (matchData.status === 'matched' && matchData.gameId) {
        // EÅŸleÅŸme bulundu
        joinOnlineGame(matchData.gameId, matchData.playerRole);
      } else if (matchData.status === 'timeout') {
        // Zaman aÅŸÄ±mÄ±
        matchStatusText.textContent = "EÅŸleÅŸme bulunamadÄ±. Tekrar deneyin.";
        findMatchBtn.disabled = false;
        matchmakingRef.remove();
        clearTimeout(matchTimeout);
      }
    });

    // EÅŸleÅŸme bulmaya Ã§alÄ±ÅŸ (30 seconds iÃ§inde)
    matchTimeout = setTimeout(() => {
      matchmakingRef.transaction((currentData) => {
        if (currentData && currentData.status === 'waiting') {
          currentData.status = 'timeout';
        }
        return currentData;
      });
    }, 30000);

    // Uygun eÅŸleÅŸme ara
    database.ref('matchmaking').orderByChild('status').equalTo('waiting').once('value', (snapshot) => {
      snapshot.forEach((childSnapshot) => {
        const otherPlayer = childSnapshot.val();
        
        if (otherPlayer.playerId !== myPlayerId && otherPlayer.status === 'waiting') {
          // EÅŸleÅŸme bulundu, oyun oluÅŸtur
          const gameId = generateGameId();
          const gameRef = database.ref(`games/${gameId}`);
          
          // Oyunu baÅŸlat (ilk oyuncunun ayarlarÄ±nÄ± kullan)
          gameRef.set({
            player1: otherPlayer.playerId,
            player2: myPlayerId,
            status: 'waiting',
            config: otherPlayer.config, // Ä°lk oyuncunun ayarlarÄ±
            currentPlayer: 'player1',
            createdAt: firebase.database.ServerValue.TIMESTAMP
          });

          // Her iki oyuncuya da bilgi ver
          database.ref(`matchmaking/${childSnapshot.key}`).update({
            gameId: gameId,
            playerRole: 'player1',
            status: 'matched'
          });
          
          matchmakingRef.update({
            gameId: gameId,
            playerRole: 'player2',
            status: 'matched'
          });
          
          // EÅŸleÅŸme kayÄ±tlarÄ±nÄ± temizle
          setTimeout(() => {
            database.ref(`matchmaking/${childSnapshot.key}`).remove();
            matchmakingRef.remove();
          }, 5000);
          
          return true; // DÃ¶ngÃ¼yÃ¼ sonlandÄ±r
        }
      });
    });
  }

  function joinOnlineGame(gameId, role) {
    playerRole = role;
    currentGameRef = database.ref(`games/${gameId}`);
    
    matchStatusText.textContent = `Match found! Game ID: ${gameId}`;
    matchProgress.style.display = 'none';
    
    currentGameRef.on('value', (snapshot) => {
      const game = snapshot.val();
      if (!game) return;
  // BURAYA EK: obstacles henÃ¼z hazÄ±r deÄŸilse bekle
  if (game.status === 'playing' && (!game.obstacles || Object.keys(game.obstacles).length === 0)) {
    return; // obstacles henÃ¼z hazÄ±r deÄŸil
  }

  startOnlineGame(game);

  if (game.moves) {
    processOnlineMoves(game.moves);
  }

  if (game.winner && !hasShownResult) {
    showOnlineResult(game.winner);
      }
    });
  }

  function startOnlineGame(gameData) {
  edges = [];
  lastPoint = null;
    isOnlineGame = true;
    gameActive = true;
    
    // Grid boyutlarÄ±nÄ± ve zorluÄŸu ayarla
    gridW = gameData.config.gridWidth;
    gridH = gameData.config.gridHeight;
    difficultySelect.value = gameData.config.difficulty;
    
    // UI gÃ¼ncellemeleri
    document.getElementById('gridWidth').value = gridW;
    document.getElementById('gridHeight').value = gridH;
    
    // Engel ve kilitli noktalarÄ± senkronize et
    obstacles = gameData.obstacles || [];
    
    // Kimin sÄ±rasÄ± olduÄŸunu belirle
    currentPlayer = gameData.currentPlayer === 'player1' ? 1 : 2;
    
    resizeCanvas();
    updateOnlineStatus(`Game started! (Turn: ${currentPlayer === (playerRole === 'player1' ? 1 : 2) ? 'You' : 'Opponent'})`, playerRole);
  }

  function sendOnlineMove(move) {
    currentGameRef.child('moves').push({
      ...move,
      timestamp: firebase.database.ServerValue.TIMESTAMP
    });
    
    // SÄ±rayÄ± deÄŸiÅŸtir
    const nextPlayer = playerRole === 'player1' ? 'player2' : 'player1';
    currentGameRef.update({
      currentPlayer: nextPlayer
    });
  }

  function processOnlineMoves(moves) {
    Object.entries(moves).forEach(([moveId, move]) => {
      if (!isMoveProcessed(move)) {
        processMoveLocally(move);
      }
    });
  }

  function isMoveProcessed(move) {
    return edges.some(e => 
      e.from.x === move.from.x && e.from.y === move.from.y &&
      e.to.x === move.to.x && e.to.y === move.to.y &&
      e.player === move.player
    );
  }

  function endOnlineGame(winner) {
  if (hasShownResult) return;
  hasShownResult = true;
  currentGameRef.update({ 
    winner: winner,
    status: 'finished',
    endedAt: firebase.database.ServerValue.TIMESTAMP
  }).then(() => {
    const isWinner = winner === (playerRole === "player1" ? 1 : 2);
    if (isWinner) {
      document.getElementById("winnerText").textContent = "Congratulations, You Won!";
      document.getElementById("winnerModal").style.display = 'flex';
    } else {
      document.getElementById("loserText").textContent = "Unfortunately, You Lost!";
      document.getElementById("loserModal").style.display = 'flex';
    }
    cleanupOnlineGame();
  });
}

  function showOnlineResult(winner) {
  if (hasShownResult) return;
  hasShownResult = true;
    const isWinner = winner === (playerRole === "player1" ? 1 : 2);
    if (isWinner) {
      winnerText.textContent = "Congratulations, You Won!";
      winnerModal.style.display = 'flex';
    } else {
      loserText.textContent = "Unfortunately, You Lost!";
      loserModal.style.display = 'flex';
    }
    cleanupOnlineGame();
  }

  function cleanupOnlineGame() {
    if (currentGameRef) {
      currentGameRef.off();
      currentGameRef = null;
    }
    if (matchmakingRef) {
      matchmakingRef.off();
      matchmakingRef.remove();
      matchmakingRef = null;
    }
    if (matchTimeout) {
      clearTimeout(matchTimeout);
    }
    isOnlineGame = false;
    playerRole = null;
    updateOnlineStatus('', '');
    findMatchBtn.disabled = false;
    matchStatus.style.display = 'none';
    matchProgress.style.display = 'block';
  }

  function updateOnlineStatus(text, role) {
    const statusElement = document.getElementById('onlineStatus');
    const textElement = document.getElementById('gameStatusText');
    const badgeElement = document.getElementById('playerRoleBadge');
    
    textElement.textContent = text;
    badgeElement.textContent = role === 'player1' ? 'Player 1' : 'Player 2';
    badgeElement.className = 'badge ' + (role === 'player1' ? 'player1-badge' : 'player2-badge');
    
    statusElement.style.display = text ? 'block' : 'none';
  }

  function generateGameId() {
    return 'game-' + Math.random().toString(36).substr(2, 8);
  }

  function showWinner(winner, text) {
    if (winner === 1) {
      winnerText.textContent = text;
      winnerModal.style.display = 'flex';
    } else {
      loserText.textContent = text;
      loserModal.style.display = 'flex';
    }
  }

  // BaÄŸlantÄ± kontrolÃ¼
  function setupConnectionMonitoring() {
    const connectedRef = database.ref(".info/connected");
    connectedRef.on("value", (snap) => {
      if (snap.val() === false) {
        // BaÄŸlantÄ± kesildi
        if (isOnlineGame && gameActive) {
          endOnlineGame(playerRole === 'player1' ? 2 : 1);
        }
        if (matchmakingRef) {
          matchmakingRef.remove();
        }
      }
    });
  }

  // Oyun baÅŸlatma
  function startGame() {
    const mode = modeSelect.value;
    
    gridW = parseInt(document.getElementById('gridWidth').value);
    gridH = parseInt(document.getElementById('gridHeight').value);
    edges = [];
    lastPoint = null;
    gameActive = true;
    
    if (mode !== 'online') {
      generateObstacles();
      currentPlayer = mode === 'robot' ? 2 : 1; // Robot modunda robot baÅŸlasÄ±n
      if (mode === 'robot' && currentPlayer === 2) {
        setTimeout(robotMove, 500);
      }
    }
    
    winnerModal.style.display = 'none';
    loserModal.style.display = 'none';
    resizeCanvas();
  }

  // Mod seÃ§imi deÄŸiÅŸtiÄŸinde
  modeSelect.addEventListener('change', function() {
    if (this.value === 'online') {
      document.getElementById('onlinePanel').style.display = 'block';
      document.getElementById('firstMoveHelp').style.display = 'none';
      document.getElementById('findMatchBtn').disabled = false;
      document.getElementById('matchStatus').style.display = 'none';
    
  // ðŸ”§ Robot oyunundan kalan sahneyi temizle
  edges = [];
  lastPoint = null;
  obstacles = [];
  drawGrid();
} else {
      document.getElementById('onlinePanel').style.display = 'none';
      document.getElementById('firstMoveHelp').style.display = 'block';
      if (currentGameRef) {
        cleanupOnlineGame();
      }
      if (matchmakingRef) {
        matchmakingRef.remove();
        matchmakingRef = null;
      }
    }
  });

  // EÅŸleÅŸme butonu
  findMatchBtn.addEventListener('click', findOnlineMatch);

  // Sayfa yÃ¼klendiÄŸinde
  window.addEventListener('DOMContentLoaded', function() {
    initTutorial();
    if (modeSelect.value !== 'online') { startGame(); }
    startGame();
    setupConnectionMonitoring();
  });
  
  window.addEventListener('resize', resizeCanvas);

  // Ã–ÄŸretici fonksiyonlarÄ±
  function initTutorial() {
    const tutorialModal = document.getElementById('tutorialModal');
    const closeTutorial = document.getElementById('closeTutorial');
    const prevBtn = document.getElementById('prevStep');
    const nextBtn = document.getElementById('nextStep');
    const skipBtn = document.getElementById('skipTutorial');
    const steps = document.querySelectorAll('.tutorial-step');
    let currentStep = 1;

    // Ã–ÄŸretici canvaslarÄ±nÄ± Ã§iz
    drawTutorialCanvases();

    closeTutorial.addEventListener('click', () => {
      tutorialModal.style.display = 'none';
    });

    nextBtn.addEventListener('click', () => {
      if (currentStep < steps.length) {
        document.querySelector(`.tutorial-step[data-step="${currentStep}"]`).style.display = 'none';
        currentStep++;
        document.querySelector(`.tutorial-step[data-step="${currentStep}"]`).style.display = 'block';
        prevBtn.disabled = currentStep === 1;
        nextBtn.textContent = currentStep === steps.length ? 'Finish' : 'Next';
      } else {
        tutorialModal.style.display = 'none';
      }
    });

    prevBtn.addEventListener('click', () => {
      if (currentStep > 1) {
        document.querySelector(`.tutorial-step[data-step="${currentStep}"]`).style.display = 'none';
        currentStep--;
        document.querySelector(`.tutorial-step[data-step="${currentStep}"]`).style.display = 'block';
        prevBtn.disabled = currentStep === 1;
        nextBtn.textContent = 'Next';
      }
    });

    skipBtn.addEventListener('click', () => {
      tutorialModal.style.display = 'none';
    });
  }

  function drawTutorialCanvases() {
    const canvas1 = document.getElementById('tutorialCanvas1');
    const ctx1 = canvas1.getContext('2d');
    drawTutorialGrid(ctx1, canvas1.width, canvas1.height);
    drawTutorialPoint(ctx1, 0, 4, '#34A853');
    drawTutorialPoint(ctx1, 5, 0, '#EA4335');

    const canvas2 = document.getElementById('tutorialCanvas2');
    const ctx2 = canvas2.getContext('2d');
    drawTutorialGrid(ctx2, canvas2.width, canvas2.height);
    drawTutorialPoint(ctx2, 0, 4, '#34A853');
    drawTutorialPoint(ctx2, 5, 0, '#EA4335');
    drawTutorialPoint(ctx2, 0, 3, '#4285F4', true);
    drawTutorialPoint(ctx2, 1, 4, '#4285F4', true);
    drawTutorialLine(ctx2, 0, 4, 1, 4, '#5e35b1');

    const canvas3 = document.getElementById('tutorialCanvas3');
    const ctx3 = canvas3.getContext('2d');
    drawTutorialGrid(ctx3, canvas3.width, canvas3.height);
    drawTutorialPoint(ctx3, 0, 4, '#34A853');
    drawTutorialPoint(ctx3, 5, 0, '#EA4335');
    drawTutorialLine(ctx3, 0, 4, 1, 4, '#5e35b1');
    drawTutorialLine(ctx3, 1, 4, 2, 3, '#5e35b1');
    drawTutorialLine(ctx3, 2, 3, 3, 2, '#5e35b1');
    drawTutorialLine(ctx3, 3, 2, 4, 1, '#5e35b1');
    drawTutorialPoint(ctx3, 4, 1, '#FBBC05');
  }

  function drawTutorialGrid(ctx, width, height) {
    ctx.clearRect(0, 0, width, height);
    const padding = width * 0.1;
    const gridW = 6, gridH = 5;
    
    ctx.strokeStyle = '#e0e0e0';
    ctx.lineWidth = 1;
    
    for (let x = 0; x < gridW; x++) {
      const px = padding + (x * (width - 2*padding)) / (gridW - 1);
      ctx.beginPath();
      ctx.moveTo(px, padding);
      ctx.lineTo(px, height - padding);
      ctx.stroke();
    }
    
    for (let y = 0; y < gridH; y++) {
      const py = padding + (y * (height - 2*padding)) / (gridH - 1);
      ctx.beginPath();
      ctx.moveTo(padding, py);
      ctx.lineTo(width - padding, py);
      ctx.stroke();
    }
  }

  function drawTutorialPoint(ctx, x, y, color, isHollow = false) {
    const padding = ctx.canvas.width * 0.1;
    const px = padding + (x * (ctx.canvas.width - 2*padding)) / 5;
    const py = padding + (y * (ctx.canvas.height - 2*padding)) / 4;
    
    ctx.beginPath();
    ctx.arc(px, py, 10, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    
    if (isHollow) {
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }

  function drawTutorialLine(ctx, x1, y1, x2, y2, color) {
    const padding = ctx.canvas.width * 0.1;
    const p1x = padding + (x1 * (ctx.canvas.width - 2*padding)) / 5;
    const p1y = padding + (y1 * (ctx.canvas.height - 2*padding)) / 4;
    const p2x = padding + (x2 * (ctx.canvas.width - 2*padding)) / 5;
    const p2y = padding + (y2 * (ctx.canvas.height - 2*padding)) / 4;
    
    ctx.beginPath();
    ctx.moveTo(p1x, p1y);
    ctx.lineTo(p2x, p2y);
    ctx.strokeStyle = color;
    ctx.lineWidth = 4;
    ctx.stroke();
  }

  // DiÄŸer event listener'lar
  startButton.addEventListener('click', () => {
    if (modeSelect.value !== 'online') {
      startGame();
    }
  });
  playAgainBtn.addEventListener('click', startGame);
  tryAgainBtn.addEventListener('click', startGame);
  helpButton.addEventListener('click', () => helpModal.style.display = 'flex');
  closeModal.addEventListener('click', () => helpModal.style.display = 'none');
</script>
<script>
let moveTimer = null;
let moveTimeLeft = 20;

function startMoveTimer() {
  clearInterval(moveTimer);
  moveTimeLeft = 20;
  document.getElementById("turnTimer").style.display = 'block';
  document.getElementById("timeLeft").textContent = moveTimeLeft;

  moveTimer = setInterval(() => {
    moveTimeLeft--;
    document.getElementById("timeLeft").textContent = moveTimeLeft;
    if (moveTimeLeft <= 0) {
      clearInterval(moveTimer);
      if (isOnlineGame && gameActive) {
        endOnlineGame(playerRole === 'player1' ? 2 : 1);
      }
    }
  }, 1000);
}

const originalProcessMoveLocally = processMoveLocally;
processMoveLocally = function(move) {
  originalProcessMoveLocally(move);
  const opponentPlayer = playerRole === 'player1' ? 2 : 1;
  if (isOnlineGame) {
    const isMyTurnNow = (playerRole === 'player1' && currentPlayer === 1) || (playerRole === 'player2' && currentPlayer === 2);
    if (isMyTurnNow) {
      startMoveTimer();
    } else {
      clearInterval(moveTimer);
      document.getElementById("turnTimer").style.display = 'none';
    }
  }
};

const originalStartOnlineGame = startOnlineGame;
startOnlineGame = function(gameData) {
  originalStartOnlineGame(gameData);
  const isMyTurn = (playerRole === 'player1' && gameData.currentPlayer === 'player1') ||
                     (playerRole === 'player2' && gameData.currentPlayer === 'player2');
  if (isMyTurn) {
    startMoveTimer();
  } else {
    clearInterval(moveTimer);
    document.getElementById("turnTimer").style.display = 'none';
  }
};

const originalEndOnlineGame = endOnlineGame;
endOnlineGame = function(winner) {
  clearInterval(moveTimer);
  document.getElementById("turnTimer").style.display = 'none';
  originalEndOnlineGame(winner);
};

function leaveOnlineGame() {
  if (!isOnlineGame || !currentGameRef) return;
  const winner = playerRole === 'player1' ? 2 : 1;
  currentGameRef.update({
    winner: winner,
    status: 'finished',
    endedAt: firebase.database.ServerValue.TIMESTAMP
  }).then(() => {
    alert("You left the game. The opponent wins.");
    cleanupOnlineGame();
  });
}

document.getElementById('leaveGameBtn').addEventListener('click', leaveOnlineGame);

const originalJoinOnlineGame = joinOnlineGame;
joinOnlineGame = function(gameId, role) {
  originalJoinOnlineGame(gameId, role);
  document.getElementById('leaveGameBtn').style.display = 'block';
};

const originalCleanupOnlineGame = cleanupOnlineGame;
cleanupOnlineGame = function() {
  clearInterval(moveTimer);
  document.getElementById("turnTimer").style.display = 'none';
  document.getElementById('leaveGameBtn').style.display = 'none';
  originalCleanupOnlineGame();
};
</script>
<script>
function updateWinnerBackground() {
  const winnerText = document.getElementById("winnerText");
  const loserText = document.getElementById("loserText");

  if (winnerText) {
    const text = winnerText.textContent.toLowerCase();
    if (text.includes("congratulations")) {
      winnerText.style.backgroundColor = "#34A853";
      winnerText.style.color = "white";
    } else if (text.includes("unfortunately")) {
      winnerText.style.backgroundColor = "#EA4335";
      winnerText.style.color = "white";
    }
  }

  if (loserText) {
    const text = loserText.textContent.toLowerCase();
    if (text.includes("unfortunately")) {
      loserText.style.backgroundColor = "#EA4335";
      loserText.style.color = "white";
    } else if (text.includes("congratulations")) {
      loserText.style.backgroundColor = "#34A853";
      loserText.style.color = "white";
    }
  }
}

// YazÄ±larÄ±n gÃ¶rÃ¼nmesi biraz zaman alabilir, bu yÃ¼zden gecikmeli Ã§alÄ±ÅŸtÄ±r
setTimeout(updateWinnerBackground, 100);
</script><script>
function showResultModal(message) {
    const modal = document.getElementById("resultModal");
    const modalMessage = document.getElementById("resultMessage");
    modalMessage.textContent = message;

    // Set background color based on result
    if (message.toLowerCase().includes("won") || message.toLowerCase().includes("congratulations")) {
        modal.style.backgroundColor = "#4CAF50"; // green
    } else if (message.toLowerCase().includes("lost") || message.toLowerCase().includes("unfortunately")) {
        modal.style.backgroundColor = "#f44336"; // red
    } else {
        modal.style.backgroundColor = "#ffffff"; // default white
    }

    modal.style.display = "block";
}
</script>

<script>
// Touch-event dÃ¼zeltme
canvas.addEventListener("touchstart", function(e) {
  e.preventDefault(); // VarsayÄ±lan davranÄ±ÅŸÄ± engelle
  const rect = canvas.getBoundingClientRect();
  const touch = e.touches[0];
  const mx = touch.clientX - rect.left;
  const my = touch.clientY - rect.top;

  let minDist = Infinity;
  let closestPoint = null;

  for (let y = 0; y < gridH; y++) {
    for (let x = 0; x < gridW; x++) {
      if (isObstacle({x, y})) continue;
      const canvasCoords = toCanvasCoords({x, y});
      const dist = Math.sqrt((mx - canvasCoords.x) ** 2 + (my - canvasCoords.y) ** 2);
      if (dist < minDist && dist < 20) {
        minDist = dist;
        closestPoint = {x, y};
      }
    }
  }
  if (closestPoint) {
    makeMove(closestPoint);
  }
}, { passive: false });
</script>


<script>
function toggleDarkMode() {
  document.body.classList.toggle("dark-mode");
}
</script>
<style>
.dark-mode {
  background-color: #121212 !important;
  color: #ffffff !important;
}
.dark-mode .game-container {
  background-color: #1e1e1e !important;
  color: white !important;
}
.dark-mode .btn {
  border: 1px solid #ccc !important;
}
.dark-mode h1 {
  background: linear-gradient(to right, #000428, #004e92) !important;
  color: white !important;
}
</style>




</body>
</html>
<script>
function isVictory(p) {
  return p.x === gridW - 1 && p.y === 0;
}

function getAvailableMoves(from) {
  const moves = [];
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      if (dx === 0 && dy === 0) continue;
      const nx = from.x + dx;
      const ny = from.y + dy;
      if (nx >= 0 && ny >= 0 && nx < gridW && ny < gridH) {
        const next = { x: nx, y: ny };
        if (!edgeExists(from, next) && !isObstacle(next)) {
          moves.push(next);
        }
      }
    }
  }
  return moves;
}

function getMediumMove(from) {
  const options = getAvailableMoves(from);
  const goal = { x: gridW - 1, y: 0 };

  return options.reduce((best, move) => {
    const dist = Math.hypot(goal.x - move.x, goal.y - move.y);
    const score = dist + Math.random() * 2;
    return !best || score < best.score ? { move, score } : best;
  }, null)?.move || null;
}

function getHardMove(from) {
  const options = getAvailableMoves(from);
  const goal = { x: gridW - 1, y: 0 };

  let bestMove = null;
  let bestScore = -Infinity;

  for (const move of options) {
    edges.push({ from, to: move, player: 2 });
    const playerOptions = getAvailableMoves(move);
    edges.pop();

    const dist = Math.hypot(goal.x - move.x, goal.y - move.y);
    let score = -dist;
    score -= playerOptions.length * 3;

    if (score > bestScore) {
      bestScore = score;
      bestMove = move;
    }
  }
  return bestMove || options[0];
}

function getExpertMove(from) {
  const options = getAvailableMoves(from);
  if (options.length === 0) return null;

  let bestMove = null;
  let bestScore = -Infinity;
  const goal = { x: gridW - 1, y: 0 };

  for (const move of options) {
    edges.push({ from, to: move, player: 2 });
    const playerMoves = getAvailableMoves(move);

    let totalScore = 0;
    let loseImmediately = false;

    if (playerMoves.length === 0) {
      edges.pop();
      return move;
    }

    for (const pMove of playerMoves) {
      edges.push({ from: move, to: pMove, player: 1 });

      if (isVictory(pMove)) {
        loseImmediately = true;
        edges.pop();
        break;
      }

      const robotReplies = getAvailableMoves(pMove);

      for (const reply of robotReplies) {
        edges.push({ from: pMove, to: reply, player: 2 });
        const playerOptions = getAvailableMoves(reply);

        let score = 0;
        if (playerOptions.length === 0) score += 1000;
        if (isVictory(reply)) score += 500;
        score -= Math.hypot(goal.x - reply.x, goal.y - reply.y) * 2;
        score -= playerOptions.length * 10;

        totalScore += score;
        edges.pop();
      }

      edges.pop();
    }

    edges.pop();

    if (loseImmediately) continue;

    if (totalScore > bestScore) {
      bestScore = totalScore;
      bestMove = move;
    }
  }

  return bestMove;
}

function getBestMove(from) {
  const settings = {
    easy: { mistakeRate: 0.5 },
    medium: { mistakeRate: 0.3 },
    hard: { mistakeRate: 0.04 },
    expert: { mistakeRate: 0.0001 }
  }[difficultySelect.value];

  if (Math.random() < settings.mistakeRate) {
    const options = getAvailableMoves(from);
    return options.length > 0 ? options[Math.floor(Math.random() * options.length)] : null;
  }

  switch (difficultySelect.value) {
    case 'expert': return getExpertMove(from);
    case 'hard': return getHardMove(from);
    case 'medium': return getMediumMove(from);
    default:
      const options = getAvailableMoves(from);
      return options.length > 0 ? options[Math.floor(Math.random() * options.length)] : null;
  }
}

function robotMove() {
  if (!gameActive || modeSelect.value !== "robot") return;
  const move = getBestMove(lastPoint);
  if (move) {
    makeMove(move);
  } else {
    endGame(1);
  }
}
</script>
<script>
function toggleStatsPopup() {
  const popup = document.getElementById("statsPopup");
  popup.style.display = popup.style.display === "none" ? "block" : "none";
}

function loadStats() {
  const wins = parseInt(localStorage.getItem("vectoryWins") || 0);
  const losses = parseInt(localStorage.getItem("vectoryLosses") || 0);
  const games = wins + losses;
  const winRate = games > 0 ? ((wins / games) * 100).toFixed(1) + "%" : "0%";

  document.getElementById("wins").textContent = wins;
  document.getElementById("losses").textContent = losses;
  document.getElementById("gamesPlayed").textContent = games;
  document.getElementById("winRate").textContent = winRate;
}

function updateStats(winner) {
  if (winner === 2) {
    const wins = parseInt(localStorage.getItem("vectoryWins") || 0) + 1;
    localStorage.setItem("vectoryWins", wins);
  } else if (winner === 1) {
    const losses = parseInt(localStorage.getItem("vectoryLosses") || 0) + 1;
    localStorage.setItem("vectoryLosses", losses);
  }
  loadStats();
}

const originalEndGame = window.endGame;
window.endGame = function(winner) {
  updateStats(winner);
  if (originalEndGame) originalEndGame(winner);
};

window.addEventListener("load", loadStats);
</script>
<!-- ðŸ“Š Statistics GÃ¶ster Butonu -->
<!-- Popup Panel -->
<div id="statsPopup" style="display:none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
background: white; border: 2px solid #444; padding: 20px; z-index: 1001; box-shadow: 0 0 10px rgba(0,0,0,0.5); border-radius: 10px;">
<h3>Statisticsler</h3>
<p>Wins: <span id="wins">0</span></p>
<p>Losses: <span id="losses">0</span></p>
<p>Games Played: <span id="gamesPlayed">0</span></p>
<p>Win Rate: <span id="winRate">0%</span></p>
<button onclick="toggleStatsPopup()">Close</button>
</div>
<style>
@media (max-width: 600px) {
  #statsPopup {
    width: 90%;
    font-size: 14px;
  }
}

@media (max-width: 600px) {
  .game-container {
    padding: 10px;
  }
  
    canvas {
      border: 2px solid #e0e0e0;
      background-color: #e6f7f5;
      display: block;
      margin: 0 auto 20px auto;
      width: 100%;
      max-width: 450px;
      height: 450px;
    }

  .d-flex.flex-wrap {
    flex-direction: column;
    align-items: center;
  }
  .d-flex.flex-wrap button,
  .d-flex.flex-wrap select,
  .d-flex.flex-wrap input {
    width: 90% !important;
    margin-bottom: 8px;
  }
}

</style>
<script>
function toggleStatsPopup() {
  const popup = document.getElementById("statsPopup");
  popup.style.display = popup.style.display === "none" ? "block" : "none";
}

function loadStats() {
  const wins = parseInt(localStorage.getItem("vectoryWins") || 0);
  const losses = parseInt(localStorage.getItem("vectoryLosses") || 0);
  const games = wins + losses;
  const winRate = games > 0 ? ((wins / games) * 100).toFixed(1) + "%" : "0%";

  document.getElementById("wins").textContent = wins;
  document.getElementById("losses").textContent = losses;
  document.getElementById("gamesPlayed").textContent = games;
  document.getElementById("winRate").textContent = winRate;
}

function updateStats(winner) {
  if (winner === 2) {
    const wins = parseInt(localStorage.getItem("vectoryWins") || 0) + 1;
    localStorage.setItem("vectoryWins", wins);
  } else if (winner === 1) {
    const losses = parseInt(localStorage.getItem("vectoryLosses") || 0) + 1;
    localStorage.setItem("vectoryLosses", losses);
  }
  loadStats();
}

const originalEndGame = window.endGame;
window.endGame = function(winner) {
  updateStats(winner);
  if (originalEndGame) originalEndGame(winner);
};

window.addEventListener("load", loadStats);
</script>
